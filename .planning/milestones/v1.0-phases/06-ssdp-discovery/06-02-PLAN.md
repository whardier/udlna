---
phase: 06-ssdp-discovery
plan: 02
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - src/ssdp/service.rs
  - src/main.rs
autonomous: true
requirements:
  - DISC-01
  - DISC-02
  - DISC-03
  - DISC-04
  - CLI-06

must_haves:
  truths:
    - "Server responds to M-SEARCH with a unicast reply containing the correct LOCATION URL"
    - "Server sends NOTIFY alive 2-3 times on startup with 100-200ms delays between each"
    - "Server re-sends NOTIFY alive every 900 seconds (re-advertisement interval)"
    - "Ctrl+C causes NOTIFY byebye to be sent for all 5 USN types before process exits"
    - "Second Ctrl+C during shutdown wait exits immediately (force exit)"
    - "SSDP socket bind failure aborts with a clear error message (not silent degradation)"
    - "SSDP advertises only after HTTP server is accepting connections (no race window)"
    - "Startup log line shows the interface address(es) being advertised on"
  artifacts:
    - path: "src/ssdp/service.rs"
      provides: "SsdpConfig, run() async task: M-SEARCH recv loop + re-advertisement timer + shutdown"
      exports: ["SsdpConfig", "run"]
    - path: "src/main.rs"
      provides: "Shutdown broadcast channel, startup sequencing, SSDP task spawn, byebye timeout"
      contains: "broadcast::channel"
  key_links:
    - from: "src/main.rs"
      to: "src/ssdp/service.rs"
      via: "tokio::spawn(ssdp::service::run(...))"
      pattern: "ssdp::service::run"
    - from: "src/ssdp/service.rs"
      to: "src/ssdp/socket.rs"
      via: "build_recv_socket_v4, build_send_socket"
      pattern: "socket::build_recv_socket_v4"
    - from: "src/ssdp/service.rs"
      to: "src/ssdp/messages.rs"
      via: "notify_alive, notify_byebye, msearch_response, usn_set"
      pattern: "messages::notify_alive"
    - from: "main.rs shutdown"
      to: "ssdp service"
      via: "broadcast::Receiver<()> shutdown_rx"
      pattern: "shutdown_rx\\.recv"
---

<objective>
Implement the SSDP service task (`src/ssdp/service.rs`) and restructure `main.rs` to add graceful shutdown, correct startup sequencing, and SSDP task lifecycle management.

Purpose: This plan wires all Phase 6 requirements into a working system: M-SEARCH response (DISC-01), startup NOTIFY burst (DISC-02), periodic re-advertisement (DISC-03), Ctrl+C byebye (DISC-04), and graceful shutdown (CLI-06).
Output: A running server that DLNA clients can discover via SSDP, with clean byebye on exit.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ssdp-discovery/06-CONTEXT.md
@.planning/phases/06-ssdp-discovery/06-RESEARCH.md
@.planning/phases/06-ssdp-discovery/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/ssdp/service.rs — async SSDP task with M-SEARCH, re-advertisement, and shutdown</name>
  <files>src/ssdp/service.rs</files>
  <action>
Create `src/ssdp/service.rs` with the `SsdpConfig` struct and `run()` async function.

**SsdpConfig struct** (passed from main.rs):

```rust
pub struct SsdpConfig {
    pub device_uuid: String,     // Must match AppState.server_uuid (Pitfall 7)
    pub http_port: u16,          // HTTP server port for constructing LOCATION URL
}
```

**run() function signature:**

```rust
pub async fn run(
    config: SsdpConfig,
    mut shutdown_rx: tokio::sync::broadcast::Receiver<()>,
)
```

**Implementation logic:**

1. **Interface discovery:** Call `socket::list_non_loopback_v4()`. If empty, log a warning (`tracing::warn!("SSDP: no non-loopback IPv4 interfaces found — SSDP disabled, HTTP still works")`) and return early (do NOT abort — per CONTEXT.md decision).

2. **Socket creation:** Call `socket::build_recv_socket_v4(iface.addr)` for each IPv4 interface. If any socket bind fails with "Address already in use" (ErrorKind::AddrInUse), print a clear error message to stderr and call `std::process::exit(1)`:
   - `eprintln!("error: SSDP port 1900 is already in use — another UPnP daemon may be running. Stop it and retry.")`
   - Per CONTEXT.md: abort, do NOT silently fall back.

   Also call `socket::build_send_socket()` for the send socket (used for NOTIFY multicast and M-SEARCH responses).

3. **Startup log:** After successful socket creation, log each interface being advertised:
   - `tracing::info!("SSDP advertising on {}:1900", iface.addr);` for each interface.

4. **USN set:** Build `messages::usn_set(&config.device_uuid)` once.

5. **Startup NOTIFY burst:** For each interface, for each (nt, usn) in the USN set, send a NOTIFY alive multicast to 239.255.255.250:1900. Send the full burst 3 times total with 150ms delay between bursts (not between individual messages):
   ```
   for i in 0..3 {
       if i > 0 { tokio::time::sleep(Duration::from_millis(150)).await; }
       for iface in &ifaces {
           let location = format!("http://{}:{}/device.xml", iface.addr, config.http_port);
           for (nt, usn) in &usn_set {
               let msg = messages::notify_alive(&location, nt, usn);
               let _ = send_socket.send_to(msg.as_bytes(), "239.255.255.250:1900").await;
           }
       }
   }
   ```

6. **Main event loop:** Use `tokio::select!` with three branches:
   - Re-advertisement timer tick (every 900s): re-send NOTIFY alive burst (same as startup burst)
   - Recv socket data (M-SEARCH): parse and respond
   - Shutdown signal: send byebye and return

   Set up re-advertisement timer — skip the immediate first tick (startup burst already sent):
   ```rust
   let mut re_advert = tokio::time::interval(Duration::from_secs(900));
   re_advert.tick().await; // skip immediate first tick
   ```

   The recv loop reads from `recv_socket.recv_from(&mut buf)`. Parse the packet as UTF-8 (lossy). Check if it starts with `M-SEARCH * HTTP/1.1`. Check for `MAN: "ssdp:discover"` (case-insensitive header scan). Extract `ST:` value. Only respond to: `ssdp:all`, `upnp:rootdevice`, `uuid:{our-uuid}`, `urn:schemas-upnp-org:device:MediaServer:1`, `urn:schemas-upnp-org:service:ContentDirectory:1`, `urn:schemas-upnp-org:service:ConnectionManager:1`.

   For `ssdp:all`: respond with all 5 USN types, one response per type, unicast to sender.
   For specific ST: respond only with the matching (NT, USN) pair. ST value = NT value in the response.

   LOCATION URL for M-SEARCH response: use `socket::find_iface_for_sender(sender_ip, &ifaces)` where `sender_ip` is the IPv4 address from `recv_from`'s returned `SocketAddr`. Fall back to first interface.

   For M-SEARCH responses, send via `send_socket.send_to(msg.as_bytes(), sender_addr)` (unicast — per CONTEXT.md).

7. **Shutdown:** On receiving shutdown signal, send NOTIFY byebye for each (nt, usn) in the USN set:
   ```rust
   for iface in &ifaces {
       for (nt, usn) in &usn_set {
           let msg = messages::notify_byebye(nt, usn);
           // Send to multicast group
           let _ = send_socket.send_to(msg.as_bytes(), "239.255.255.250:1900").await;
       }
   }
   tracing::info!("SSDP: byebye sent");
   ```
   Then return (task exits cleanly).

**Buffer size:** Use a 2048-byte buffer for recv_from — M-SEARCH packets are always well under 1KB.

**Error handling:** All `send_to` calls use `let _ = ...` — UDP send errors are non-fatal for SSDP (clients retry). Log recv errors at debug level, not error level.

**Multiple recv sockets:** If there are multiple IPv4 interfaces, you need to receive from all of them. Use `tokio::select!` with multiple recv branches, or create a single shared socket (bind to 239.255.255.250:1900 receives packets for all joined interfaces on one socket). The simplest approach: one recv socket that joins all interfaces via `join_multicast_v4` calls on the same socket. Refactor `build_recv_socket_v4` if needed so the socket can join multiple multicast groups (call `join_multicast_v4` once per interface after creation). Alternatively, create one socket per interface and `tokio::select!` across them — this is more complex. Use whichever approach compiles cleanly.

**IPv6 SSDP (per CONTEXT.md locked decision — dual-stack):** After implementing IPv4 fully, add IPv6 receive on `ff02::c:1900`. Call `socket::build_recv_socket_v6(0)` (interface index 0 = any interface). If it fails (e.g., IPv6 not available), log a debug message and continue with IPv4 only — IPv6 SSDP failure is non-fatal. For IPv6 M-SEARCH responses, send the LOCATION URL using the HTTP server's IPv6 address if available, or fall back to the IPv4 LOCATION URL (most home DLNA clients are IPv4 even on dual-stack networks). NOTIFY alive/byebye for IPv6 uses the IPv6 multicast address `[ff02::c]:1900` as destination. If implementing IPv6 SSDP makes the code substantially complex, implement IPv4 fully first and add IPv6 as a best-effort extension in the same file.
  </action>
  <verify>cargo build 2>&1 | grep "^error" | head -10 (expect zero lines)</verify>
  <done>cargo build exits 0; src/ssdp/service.rs exists with SsdpConfig struct and run() async function; all symbols compile</done>
</task>

<task type="auto">
  <name>Task 2: Restructure main.rs — shutdown broadcast, startup sequencing, SSDP task, byebye timeout</name>
  <files>src/main.rs</files>
  <action>
Replace the current `main.rs` with a restructured version that adds graceful shutdown coordination. The existing startup logic (tracing, CLI parse, config load, scan, zero-file guard) must remain unchanged. Only the server launch section changes.

**Key additions:**

1. **Static shutdown flag** (for second Ctrl+C force exit):
   ```rust
   use std::sync::atomic::{AtomicBool, Ordering};
   static SHUTTING_DOWN: AtomicBool = AtomicBool::new(false);
   ```

2. **Shutdown signal helper:**
   ```rust
   async fn wait_for_shutdown() {
       loop {
           tokio::signal::ctrl_c().await.expect("failed to install Ctrl+C handler");
           if SHUTTING_DOWN.swap(true, Ordering::SeqCst) {
               eprintln!("\nudlna: forced exit");
               std::process::exit(1);
           }
           return; // first Ctrl+C: proceed with graceful shutdown
       }
   }
   ```

3. **Broadcast channel:**
   ```rust
   let (shutdown_tx, _) = tokio::sync::broadcast::channel::<()>(4);
   ```

4. **HTTP server with graceful shutdown** (replaces the bare `axum::serve().await`):
   The existing code spawns two tasks (IPv4 + IPv6) or one (localhost). Each `axum::serve()` call must gain `.with_graceful_shutdown(...)`. For the dual-bind case:
   ```rust
   let mut http_v4_rx = shutdown_tx.subscribe();
   let h4 = tokio::spawn(
       axum::serve(ipv4_listener, app_v4)
           .with_graceful_shutdown(async move { let _ = http_v4_rx.recv().await; })
   );
   let mut http_v6_rx = shutdown_tx.subscribe();
   let h6 = tokio::spawn(
       axum::serve(ipv6_listener, app)
           .with_graceful_shutdown(async move { let _ = http_v6_rx.recv().await; })
   );
   ```

5. **SSDP task spawn** (after HTTP listeners are created and before waiting for shutdown):
   ```rust
   let ssdp_config = ssdp::service::SsdpConfig {
       device_uuid: state.server_uuid.clone(),
       http_port: config.port,
   };
   let ssdp_shutdown_rx = shutdown_tx.subscribe();
   let ssdp_task = tokio::spawn(ssdp::service::run(ssdp_config, ssdp_shutdown_rx));
   ```

   **IMPORTANT startup sequencing (locked decision):** The SSDP task must be spawned AFTER the HTTP listeners are created (after `TcpListener::bind` succeeds). The `tokio::spawn` for the SSDP task means it starts concurrently with HTTP serving, but the HTTP listener is already bound and accepting connections before the SSDP startup burst fires (because the burst has a short async delay). This satisfies the "HTTP ready before SSDP advertises" requirement.

6. **Shutdown wait and orchestration:**
   ```rust
   // Wait for Ctrl+C signal
   wait_for_shutdown().await;
   tracing::info!("Shutting down — sending SSDP byebye...");

   // Broadcast shutdown to all tasks
   let _ = shutdown_tx.send(());

   // Wait up to 1 second for SSDP byebye to complete
   let _ = tokio::time::timeout(
       std::time::Duration::from_secs(1),
       ssdp_task,
   ).await;

   tracing::info!("Goodbye.");
   // HTTP tasks drain in-flight requests automatically via with_graceful_shutdown
   ```

   Replace the `tokio::join!(h4, h6)` call: after shutdown signal, the HTTP tasks are still running (draining). For the purposes of this implementation, it is acceptable to let the process exit after the SSDP timeout — the HTTP tasks will be killed by the process exit. Do NOT wait for h4/h6 after shutdown (they may take time to drain).

**Localhost mode:** Apply the same shutdown logic to the localhost branch. Single HTTP listener + SSDP task + same shutdown sequence.

**Preserve all existing behavior:** The existing startup banner, scan, zero-file guard, config merge, and path validation must remain identical. Only the server launch section changes.

After writing main.rs, run `cargo build` to confirm zero errors. Fix any type errors from the broadcast channel or signal imports.
  </action>
  <verify>cargo build 2>&1 | grep "^error" | head -10 (expect zero lines); cargo run -- /tmp 2>&1 | grep -E "SSDP|byebye|Goodbye" (expect SSDP lines on startup)</verify>
  <done>cargo build exits 0; running the server shows "SSDP advertising on {ip}:1900" in logs; Ctrl+C produces "Sending SSDP byebye" then "Goodbye." and process exits cleanly</done>
</task>

</tasks>

<verification>
- `cargo build` exits 0 with no errors
- `cargo run -- /path/to/media` logs show SSDP advertising on an interface address
- Pressing Ctrl+C causes SSDP byebye log then clean process exit within ~2 seconds
- `grep -r "\\\\r\\\\n" src/ssdp/messages.rs` confirms CRLF line endings in all message builders (not bare \n)
- `grep "device_uuid" src/ssdp/service.rs` confirms the UUID comes from SsdpConfig (not hardcoded)
</verification>

<success_criteria>
The server is fully SSDP-capable: it advertises itself on startup, responds to M-SEARCH queries, re-advertises every 900 seconds, and sends byebye on Ctrl+C. All 5 USN types are advertised. The process exits cleanly within 1-2 seconds of Ctrl+C.
</success_criteria>

<output>
After completion, create `.planning/phases/06-ssdp-discovery/06-02-SUMMARY.md`
</output>
