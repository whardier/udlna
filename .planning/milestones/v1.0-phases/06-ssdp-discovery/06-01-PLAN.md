---
phase: 06-ssdp-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/ssdp/mod.rs
  - src/ssdp/socket.rs
  - src/ssdp/messages.rs
autonomous: true
requirements:
  - DISC-01
  - DISC-02
  - DISC-03
  - DISC-04

must_haves:
  truths:
    - "SSDP socket helpers compile without error for both IPv4 and IPv6"
    - "Message builder functions produce CRLF-terminated strings matching UPnP spec format"
    - "USN set covers all 5 advertisement types: root uuid, rootdevice, MediaServer:1, ContentDirectory:1, ConnectionManager:1"
    - "Interface enumeration skips loopback and returns Ipv4Addr list"
  artifacts:
    - path: "src/ssdp/mod.rs"
      provides: "Module declarations and public re-exports"
    - path: "src/ssdp/socket.rs"
      provides: "build_recv_socket_v4, build_recv_socket_v6, build_send_socket, list_non_loopback_ipv4, find_iface_for_sender"
    - path: "src/ssdp/messages.rs"
      provides: "notify_alive, notify_byebye, msearch_response, usn_set"
    - path: "Cargo.toml"
      provides: "getifaddrs dep + signal/time/sync tokio features"
  key_links:
    - from: "src/ssdp/socket.rs"
      to: "socket2::Socket"
      via: "socket2 crate"
      pattern: "Socket::new.*Domain::IPV4"
    - from: "src/ssdp/messages.rs"
      to: "CRLF line endings"
      via: "\\r\\n in format strings"
      pattern: "\\\\r\\\\n"
---

<objective>
Add the Cargo dependencies and `src/ssdp/` foundational module: socket helpers for creating multicast UDP sockets (IPv4 + IPv6), SSDP message builders, interface enumeration, and subnet-matching LOCATION URL selection.

Purpose: All SSDP logic builds on these pure building blocks. Separating them from the async service task keeps compilation fast and each piece independently testable.
Output: Compilable `src/ssdp/` module with socket.rs, messages.rs, and mod.rs. No behavior change at runtime yet — the module is declared but not connected to main.rs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ssdp-discovery/06-CONTEXT.md
@.planning/phases/06-ssdp-discovery/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cargo.toml — add getifaddrs dep and tokio signal/time/sync features</name>
  <files>Cargo.toml</files>
  <action>
Add `getifaddrs = "0.4"` to [dependencies].

Update the tokio dependency to add three missing features: `"signal"`, `"time"`, and `"sync"`. The current features list is `["macros", "rt-multi-thread", "fs", "net", "io-util"]`. The new list must be `["macros", "rt-multi-thread", "fs", "net", "io-util", "signal", "time", "sync"]`.

Run `cargo check` after the edit to confirm the new features resolve without error. If `getifaddrs 0.4` is not available on crates.io, use `getifaddrs = "0.3"` as fallback (check `cargo search getifaddrs` output). Do NOT add any other new dependencies.
  </action>
  <verify>cargo check 2>&1 | grep -E "^error" | head -5 (expect zero lines)</verify>
  <done>cargo check exits 0 with no compilation errors; Cargo.toml shows getifaddrs and tokio with signal+time+sync features</done>
</task>

<task type="auto">
  <name>Task 2: Create src/ssdp/ module — socket.rs, messages.rs, mod.rs</name>
  <files>src/ssdp/mod.rs, src/ssdp/socket.rs, src/ssdp/messages.rs, src/main.rs</files>
  <action>
Create directory `src/ssdp/` and three files.

**src/ssdp/socket.rs** — socket creation and interface helpers:

```rust
use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4};
use socket2::{Domain, Protocol, Socket, Type};
use tokio::net::UdpSocket;

pub const SSDP_MCAST_V4: Ipv4Addr = Ipv4Addr::new(239, 255, 255, 250);
pub const SSDP_MCAST_V6: Ipv6Addr = Ipv6Addr::new(0xff02, 0, 0, 0, 0, 0, 0, 0x000c);
pub const SSDP_PORT: u16 = 1900;

/// Create a UDP socket for receiving IPv4 SSDP multicast on port 1900.
/// Binds to 239.255.255.250:1900 (Unix convention — kernel-level multicast filtering).
/// Sets SO_REUSEADDR + SO_REUSEPORT (macOS requires both).
/// Joins multicast group on `iface_addr`.
pub fn build_recv_socket_v4(iface_addr: Ipv4Addr) -> std::io::Result<UdpSocket> {
    let socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;
    socket.set_reuse_address(true)?;
    #[cfg(unix)]
    socket.set_reuse_port(true)?;
    let bind_addr: SocketAddr = SocketAddrV4::new(SSDP_MCAST_V4, SSDP_PORT).into();
    socket.bind(&bind_addr.into())?;
    socket.set_nonblocking(true)?;
    let std_udp: std::net::UdpSocket = socket.into();
    let tokio_udp = UdpSocket::from_std(std_udp)?;
    tokio_udp.join_multicast_v4(SSDP_MCAST_V4, iface_addr)?;
    Ok(tokio_udp)
}

/// Create a UDP socket for receiving IPv6 SSDP multicast (ff02::c) on port 1900.
/// Binds to [::]:1900 (Windows-compatible; IPv6 multicast binding differs per platform).
/// Joins multicast group ff02::c on `iface_index` (interface index, not address).
pub fn build_recv_socket_v6(iface_index: u32) -> std::io::Result<UdpSocket> {
    let socket = Socket::new(Domain::IPV6, Type::DGRAM, Some(Protocol::UDP))?;
    socket.set_reuse_address(true)?;
    #[cfg(unix)]
    socket.set_reuse_port(true)?;
    socket.set_only_ipv6(true)?;
    let bind_addr: SocketAddr = "[::]:1900".parse().unwrap();
    socket.bind(&bind_addr.into())?;
    socket.set_nonblocking(true)?;
    let std_udp: std::net::UdpSocket = socket.into();
    let tokio_udp = UdpSocket::from_std(std_udp)?;
    tokio_udp.join_multicast_v6(&SSDP_MCAST_V6, iface_index)?;
    Ok(tokio_udp)
}

/// Create a general-purpose send socket (not bound to multicast address).
/// Used for sending NOTIFY and M-SEARCH response packets.
/// Bind to 0.0.0.0:0 — OS picks source port; destination comes from send_to caller.
pub fn build_send_socket() -> std::io::Result<UdpSocket> {
    let socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;
    socket.set_reuse_address(true)?;
    socket.set_nonblocking(true)?;
    let bind_addr: SocketAddr = "0.0.0.0:0".parse().unwrap();
    socket.bind(&bind_addr.into())?;
    let std_udp: std::net::UdpSocket = socket.into();
    UdpSocket::from_std(std_udp)
}

/// An interface entry: IPv4 address + netmask.
#[derive(Debug, Clone)]
pub struct IfaceV4 {
    pub addr: Ipv4Addr,
    pub mask: Ipv4Addr,
    pub index: u32,
}

/// Enumerate non-loopback IPv4 interfaces using the `getifaddrs` crate.
/// Returns empty Vec if enumeration fails (not a fatal error for SSDP startup).
pub fn list_non_loopback_v4() -> Vec<IfaceV4> {
    use getifaddrs::InterfaceFlags;
    use std::net::IpAddr;

    let Ok(ifaces) = getifaddrs::getifaddrs() else {
        return vec![];
    };
    ifaces
        .filter(|i| !i.flags.contains(InterfaceFlags::LOOPBACK))
        .filter_map(|i| {
            let addr = match i.address.and_then(|a| a.as_socket_ipv4()).map(|s| s.ip().to_owned()) {
                Some(v4) => v4,
                None => {
                    // Try ip_addr() fallback
                    match i.address.and_then(|a| Some(a.as_socket()?.ip())) {
                        Some(IpAddr::V4(v4)) => v4,
                        _ => return None,
                    }
                }
            };
            // Use /24 as netmask fallback if crate doesn't expose it directly
            let mask = i.netmask
                .and_then(|m| m.as_socket_ipv4().map(|s| s.ip().to_owned()))
                .unwrap_or(Ipv4Addr::new(255, 255, 255, 0));
            Some(IfaceV4 { addr, mask, index: 0 })
        })
        .collect()
}

/// Subnet-mask matching: find the interface whose subnet contains `sender_ip`.
/// Falls back to the first interface if no match. Returns None if no interfaces.
/// This is the minidlna approach — accurate for home networks.
pub fn find_iface_for_sender(sender_ip: Ipv4Addr, ifaces: &[IfaceV4]) -> Option<Ipv4Addr> {
    for iface in ifaces {
        let sender_net = u32::from(sender_ip) & u32::from(iface.mask);
        let iface_net = u32::from(iface.addr) & u32::from(iface.mask);
        if sender_net == iface_net {
            return Some(iface.addr);
        }
    }
    ifaces.first().map(|i| i.addr)
}
```

**IMPORTANT:** The `getifaddrs` API may differ between versions. At implementation time, check what fields the `Interface` struct exposes. The fields to access are `address` (returns some socket addr type), `netmask`, and `flags`. Adapt the code to match the actual API. The `InterfaceFlags::LOOPBACK` variant name may differ — check the crate's docs or source. Use `cargo doc --open` or `cargo check` error messages to resolve.

**src/ssdp/messages.rs** — pure string builders (no I/O, no socket state):

```rust
/// The 5 USN advertisement types for a MediaServer:1 with CDS + CMS.
/// Returns Vec of (NT, USN) pairs.
pub fn usn_set(device_uuid: &str) -> Vec<(String, String)> {
    let uuid = format!("uuid:{device_uuid}");
    vec![
        // Advertisement 1: UUID only
        (uuid.clone(), uuid.clone()),
        // Advertisement 2: root device
        ("upnp:rootdevice".into(), format!("{uuid}::upnp:rootdevice")),
        // Advertisement 3: device type
        (
            "urn:schemas-upnp-org:device:MediaServer:1".into(),
            format!("{uuid}::urn:schemas-upnp-org:device:MediaServer:1"),
        ),
        // Advertisement 4: ContentDirectory service
        (
            "urn:schemas-upnp-org:service:ContentDirectory:1".into(),
            format!("{uuid}::urn:schemas-upnp-org:service:ContentDirectory:1"),
        ),
        // Advertisement 5: ConnectionManager service
        (
            "urn:schemas-upnp-org:service:ConnectionManager:1".into(),
            format!("{uuid}::urn:schemas-upnp-org:service:ConnectionManager:1"),
        ),
    ]
}

/// Build a NOTIFY alive message.
/// LOCATION is the full HTTP URL to device.xml (e.g. "http://192.168.1.5:8200/device.xml").
/// Uses CRLF (\r\n) line endings — required by SSDP/HTTP protocol. Bare \n causes silent
/// parse failures on strict clients (Samsung TVs).
pub fn notify_alive(location: &str, nt: &str, usn: &str) -> String {
    format!(
        "NOTIFY * HTTP/1.1\r\n\
         HOST: 239.255.255.250:1900\r\n\
         CACHE-CONTROL: max-age=900\r\n\
         LOCATION: {location}\r\n\
         NT: {nt}\r\n\
         NTS: ssdp:alive\r\n\
         SERVER: Linux/1.0 UPnP/1.0 udlna/0.1\r\n\
         USN: {usn}\r\n\
         \r\n"
    )
}

/// Build a NOTIFY byebye message.
/// byebye MUST NOT include CACHE-CONTROL, LOCATION, or SERVER headers — only NT/NTS/USN.
pub fn notify_byebye(nt: &str, usn: &str) -> String {
    format!(
        "NOTIFY * HTTP/1.1\r\n\
         HOST: 239.255.255.250:1900\r\n\
         NT: {nt}\r\n\
         NTS: ssdp:byebye\r\n\
         USN: {usn}\r\n\
         \r\n"
    )
}

/// Build an M-SEARCH 200 OK unicast response.
/// `st` matches the ST header from the M-SEARCH request.
pub fn msearch_response(location: &str, st: &str, usn: &str) -> String {
    format!(
        "HTTP/1.1 200 OK\r\n\
         CACHE-CONTROL: max-age=900\r\n\
         EXT:\r\n\
         LOCATION: {location}\r\n\
         SERVER: Linux/1.0 UPnP/1.0 udlna/0.1\r\n\
         ST: {st}\r\n\
         USN: {usn}\r\n\
         Content-Length: 0\r\n\
         \r\n"
    )
}
```

**src/ssdp/mod.rs**:

```rust
pub mod messages;
pub mod service;  // will be created in Plan 02
pub mod socket;
```

**src/main.rs** — add `mod ssdp;` alongside the existing mod declarations (do NOT wire it yet — just declare the module so it compiles):

Add `mod ssdp;` after `mod media;` in main.rs.

After writing all files, run `cargo check` to confirm zero errors. If the `getifaddrs` API doesn't match the code, fix the API calls to match what the crate actually exposes.
  </action>
  <verify>cargo check 2>&1 | grep "^error" | head -5 (expect zero lines)</verify>
  <done>cargo check exits 0; src/ssdp/socket.rs, messages.rs, mod.rs exist with correct content; src/main.rs has mod ssdp declaration</done>
</task>

</tasks>

<verification>
- `cargo check` exits 0 with no errors after all file writes
- `src/ssdp/socket.rs` exists and contains `build_recv_socket_v4`, `build_recv_socket_v6`, `build_send_socket`, `list_non_loopback_v4`, `find_iface_for_sender`
- `src/ssdp/messages.rs` exists and contains `notify_alive`, `notify_byebye`, `msearch_response`, `usn_set`
- `src/ssdp/mod.rs` exists and declares socket, messages, service submodules
- `Cargo.toml` shows `getifaddrs` dependency and tokio features include `signal`, `time`, `sync`
</verification>

<success_criteria>
The ssdp module compiles cleanly as a foundational building block. All socket helpers and message builders are present and correct. No behavior change at runtime — the module exists but is not yet wired into main.rs startup logic.
</success_criteria>

<output>
After completion, create `.planning/phases/06-ssdp-discovery/06-01-SUMMARY.md`
</output>
