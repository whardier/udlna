---
phase: 01-project-setup-cli
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/cli.rs
  - src/media/mod.rs
  - src/media/mime.rs
autonomous: true
requirements:
  - CLI-01
  - CLI-03
  - CLI-07

must_haves:
  truths:
    - "Running `cargo build` succeeds with no errors or warnings"
    - "Running `cargo run -- --help` prints CLI usage with positional paths and --port flag documented"
    - "Running `cargo run -- /some/path` parses the path into Vec<PathBuf> (verifiable via debug output)"
    - "The classify() function returns Some((MediaKind::Video, 'video/mp4')) for a .mp4 path and None for a .txt path"
    - ".srt files are classified as Subtitle (not skipped) per locked decision"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies declared"
      contains: "clap"
    - path: "src/cli.rs"
      provides: "clap Args struct with Vec<PathBuf> positional paths and Option<u16> port"
      exports: ["Args"]
    - path: "src/media/mime.rs"
      provides: "Extension-based MIME classification with MediaKind enum and classify() fn"
      exports: ["MediaKind", "classify"]
    - path: "src/media/mod.rs"
      provides: "Module declaration for media submodule"
  key_links:
    - from: "src/cli.rs"
      to: "src/main.rs"
      via: "pub struct Args re-exported for use in config merge"
      pattern: "use crate::cli::Args"
    - from: "src/media/mime.rs"
      to: "src/media/mod.rs"
      via: "pub mod mime declaration"
      pattern: "pub mod mime"
---

<objective>
Scaffold the Cargo project, declare all Phase 1 dependencies, define the CLI argument struct with clap derive, and implement the MIME classification module.

Purpose: Establishes the project foundation and produces the two modules that all subsequent Phase 1 work depends on — the Args struct (needed by config merge) and the classify() function (needed by the media scanner in Phase 2).

Output: Compilable Cargo project with clap-derived CLI, MIME classification with MediaKind enum, and tests proving extension detection works.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-setup-cli/01-CONTEXT.md
@.planning/phases/01-project-setup-cli/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Cargo project and declare all Phase 1 dependencies</name>
  <files>Cargo.toml, src/main.rs</files>
  <action>
    Run `cargo init --name udlna` in the working directory (if Cargo.toml does not already exist).

    Then add all Phase 1 dependencies to Cargo.toml. Do NOT use `cargo add` one at a time — write the full [dependencies] block directly:

    ```toml
    [package]
    name = "udlna"
    version = "0.1.0"
    edition = "2021"
    description = "Minimal DLNA/UPnP media server"

    [[bin]]
    name = "udlna"
    path = "src/main.rs"

    [dependencies]
    clap = { version = "4", features = ["derive"] }
    serde = { version = "1", features = ["derive"] }
    toml = "1"
    dirs = "6"
    mime_guess = "2"
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["env-filter"] }
    ```

    Leave src/main.rs as a minimal stub that compiles:
    ```rust
    mod cli;
    mod config;
    mod media;

    fn main() {
        println!("udlna stub — Phase 1 in progress");
    }
    ```

    Run `cargo build` to confirm the dependency graph resolves. If any crate version is not found, check crates.io for the latest version within the specified major version range and update accordingly (clap 4.x, serde 1.x, toml 1.x, dirs 6.x, mime_guess 2.x, tracing 0.1.x, tracing-subscriber 0.3.x).
  </action>
  <verify>
    `cargo build` exits 0.
    `cargo tree | head -20` shows clap, serde, toml, dirs, mime_guess, tracing, tracing-subscriber in the dependency list.
  </verify>
  <done>
    Cargo.toml declares all seven dependencies with correct versions. `cargo build` succeeds. src/main.rs compiles (even as a stub). No dependency resolution errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI Args struct and MIME classification module</name>
  <files>src/cli.rs, src/media/mod.rs, src/media/mime.rs</files>
  <action>
    **Create src/cli.rs** — clap derive Args struct:

    ```rust
    use clap::Parser;
    use std::path::PathBuf;

    #[derive(Parser, Debug)]
    #[command(
        name = "udlna",
        about = "Minimal DLNA/UPnP media server — `udlna /path/to/media` and it works",
        long_about = None,
        version,
        arg_required_else_help = true,
    )]
    pub struct Args {
        /// One or more directories containing media files to serve
        #[arg(num_args = 1..)]
        pub paths: Vec<PathBuf>,

        /// HTTP port to listen on [default: 8200]
        #[arg(short, long)]
        pub port: Option<u16>,

        /// Friendly server name shown on DLNA client device lists [default: udlna]
        #[arg(short, long)]
        pub name: Option<String>,

        /// Path to TOML config file (overrides default search: ./udlna.toml, ~/.config/udlna/config.toml)
        #[arg(short, long, value_name = "FILE")]
        pub config: Option<PathBuf>,
    }
    ```

    Use `Option<u16>` for port (not `u16`) so absence is detectable during the three-layer config merge in Plan 02. Do NOT set `default_value` on port or name in clap — defaults are applied in Config::resolve() in Plan 02.

    `num_args = 1..` enforces at least one path. Combined with `arg_required_else_help = true`, running `udlna` with no args prints full help (satisfies CLI-05 success criterion 5).

    Do NOT add a `--log-level` flag. Use `RUST_LOG` env var exclusively (simpler UX per research recommendation).

    **Create src/media/mod.rs**:
    ```rust
    pub mod mime;
    ```

    **Create src/media/mime.rs** — extension-based MIME classification:

    Implement the `MediaKind` enum and `classify()` function using a static match. Do NOT rely on `mime_guess` for the MIME string values — use explicit string literals per research guidance (mime_guess return values are not stable API). Use `mime_guess` only if you want a fallback for unknown extensions (but the match should handle all recognized types directly).

    The match must cover:
    - Video: mp4, m4v, mkv, avi, mov, ts, m2ts, mts, mpg, mpeg, wmv, flv, ogv, webm, 3gp
    - Audio: mp3, flac, wav, m4a, aac, ogg, oga, wma, opus, aiff, aif
    - Image: jpg, jpeg, png, gif, webp, bmp, tiff, tif
    - Subtitle: srt, vtt (LOCKED DECISION — must be recognized, classified as Subtitle, NOT skipped)
    - Everything else: return None (silent skip, no logging at this layer)

    MIME strings must be the DLNA-correct values listed in the research (e.g. "video/x-matroska" for mkv, "video/MP2T" for ts/m2ts, "audio/mpeg" for mp3).

    Add unit tests in the same file using `#[cfg(test)]`:

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use std::path::Path;

        #[test]
        fn test_mp4_classified_as_video() {
            let (kind, mime) = classify(Path::new("movie.mp4")).unwrap();
            assert_eq!(kind, MediaKind::Video);
            assert_eq!(mime, "video/mp4");
        }

        #[test]
        fn test_srt_classified_as_subtitle() {
            let (kind, mime) = classify(Path::new("movie.srt")).unwrap();
            assert_eq!(kind, MediaKind::Subtitle);
            assert_eq!(mime, "text/srt");
        }

        #[test]
        fn test_txt_returns_none() {
            assert!(classify(Path::new("readme.txt")).is_none());
        }

        #[test]
        fn test_no_extension_returns_none() {
            assert!(classify(Path::new("Makefile")).is_none());
        }

        #[test]
        fn test_case_insensitive() {
            // Extensions should be lowercased before matching
            let result = classify(Path::new("MOVIE.MP4"));
            assert!(result.is_some());
        }

        #[test]
        fn test_mp3_classified_as_audio() {
            let (kind, mime) = classify(Path::new("song.mp3")).unwrap();
            assert_eq!(kind, MediaKind::Audio);
            assert_eq!(mime, "audio/mpeg");
        }

        #[test]
        fn test_jpeg_classified_as_image() {
            let (kind, mime) = classify(Path::new("photo.jpg")).unwrap();
            assert_eq!(kind, MediaKind::Image);
            assert_eq!(mime, "image/jpeg");
        }

        #[test]
        fn test_mkv_mime_is_matroska() {
            let (_, mime) = classify(Path::new("video.mkv")).unwrap();
            assert_eq!(mime, "video/x-matroska");
        }
    }
    ```

    Update src/main.rs to add `mod config;` declaration (even though config.rs doesn't exist yet, add it commented out to avoid compilation errors — or create an empty config.rs stub):

    Create src/config.rs as a minimal stub:
    ```rust
    // Implemented in Plan 02
    ```

    This allows `mod config;` in main.rs to compile.
  </action>
  <verify>
    `cargo build` exits 0 with no errors or warnings.
    `cargo run -- --help` prints usage showing positional `[PATHS]...` and `--port` flag.
    `cargo test` runs and all MIME classification tests pass (7 tests).
    `cargo run -- /tmp` parses and does not panic.
  </verify>
  <done>
    src/cli.rs defines Args with Vec&lt;PathBuf&gt; positional (num_args = 1..) and Option&lt;u16&gt; port.
    src/media/mime.rs defines MediaKind enum (Video, Audio, Image, Subtitle), classify() function covering all required extensions, and all 7 unit tests pass.
    `cargo test` exits 0.
    `cargo run -- --help` shows proper usage (satisfies CLI-05 criterion 5 for no-args case).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0 with no errors
2. `cargo test` exits 0 — all 7 MIME unit tests pass
3. `cargo run -- --help` prints usage with paths and --port documented
4. `cargo run -- /tmp` exits without panic (stub main, no crash)
5. `cargo run` with no arguments prints help (arg_required_else_help = true)
</verification>

<success_criteria>
- Cargo.toml declares clap 4, serde 1, toml 1, dirs 6, mime_guess 2, tracing 0.1, tracing-subscriber 0.3
- `cargo build` succeeds
- `cargo test` passes all MIME tests
- src/cli.rs: Args struct with num_args=1.. on paths, Option&lt;u16&gt; port, arg_required_else_help = true
- src/media/mime.rs: classify() covers video/audio/image/subtitle extensions; .srt returns Subtitle (locked decision); unknown returns None (silent skip locked decision)
- No networking, no scanning logic — Phase 1 scope only
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-cli/01-01-SUMMARY.md` following the summary template.
</output>
