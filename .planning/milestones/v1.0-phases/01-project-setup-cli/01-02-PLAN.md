---
phase: 01-project-setup-cli
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/config.rs
  - src/main.rs
autonomous: true
requirements:
  - CLI-04
  - CLI-05

must_haves:
  truths:
    - "Running `udlna /path/to/media` with no config file starts successfully using all defaults (port 8200)"
    - "Running `udlna --port 9000 /path` stores port 9000 in the resolved config (CLI flag wins)"
    - "Placing `./udlna.toml` with `port = 9000` causes port 9000 to be used when --port is not passed"
    - "Placing `./udlna.toml` with `port = 9000` and also passing `--port 8888` uses 8888 (CLI overrides TOML)"
    - "Running `udlna /nonexistent/path` prints an error and exits 1 (fail-fast path validation)"
    - "Running `udlna /valid/path` prints a startup banner with port and path visible in tracing output"
  artifacts:
    - path: "src/config.rs"
      provides: "FileConfig (TOML deserialization), Config (resolved), find_config_file(), load_config(), Config::resolve()"
      exports: ["FileConfig", "Config", "find_config_file", "load_config"]
    - path: "src/main.rs"
      provides: "Wired entry point: logging init, CLI parse, config load, merge, path validation, startup banner"
  key_links:
    - from: "src/main.rs"
      to: "src/config.rs"
      via: "Config::resolve(file_config, &args)"
      pattern: "Config::resolve"
    - from: "src/config.rs"
      to: "dirs::config_dir()"
      via: "find_config_file() uses dirs crate for XDG path"
      pattern: "dirs::config_dir"
    - from: "src/config.rs"
      to: "src/cli.rs"
      via: "Config::resolve() takes &crate::cli::Args"
      pattern: "crate::cli::Args"
---

<objective>
Implement TOML config loading with XDG path search and the three-layer config merge (defaults -> TOML -> CLI flags), then wire everything together in main.rs with logging initialization, path validation, and startup banner.

Purpose: Completes the Phase 1 deliverable. After this plan, `udlna` is a fully functional CLI binary that satisfies all five phase success criteria — config loading, flag override precedence, sensible defaults, and a useful no-args help message.

Output: src/config.rs (FileConfig, Config, find_config_file, load_config), src/main.rs (fully wired entry point).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-setup-cli/01-CONTEXT.md
@.planning/phases/01-project-setup-cli/01-RESEARCH.md
@.planning/phases/01-project-setup-cli/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config module with TOML loading and three-layer merge</name>
  <files>src/config.rs</files>
  <action>
    Replace the stub src/config.rs with the full implementation.

    **FileConfig** — TOML-deserializable struct. All fields are Option&lt;T&gt; so absent keys don't fail deserialization. Do NOT add `#[serde(deny_unknown_fields)]` — unknown TOML keys must be silently ignored (forward compatibility, see research pitfall 2). Do NOT include `paths` in FileConfig — paths come from CLI positional args only (CLI-01).

    **Config** — Resolved struct with concrete types (no Options). All fields guaranteed to have values after merge.

    **Constants:**
    - DEFAULT_PORT: u16 = 8200
    - DEFAULT_NAME: &str = "udlna"

    **Config::resolve()** — Three-layer merge: hardcoded defaults (lowest priority) -> TOML file values -> CLI flags (highest priority). Use `.or()` chaining on Options:
    ```rust
    port: args.port.or(file.port).unwrap_or(DEFAULT_PORT)
    ```

    **find_config_file()** — Search order (per CLI-04):
    1. If `--config` flag was passed (explicit path), use it exclusively (even if it doesn't exist — let load_config() handle the error)
    2. Check `./udlna.toml` (CWD) — if exists, return it
    3. Check `dirs::config_dir().join("udlna").join("config.toml")` — if exists, return it
    4. Return None (no config file, use defaults — this is the normal case)

    Use `dirs::config_dir()` (NOT `dirs::home_dir()`) for the XDG path. On Linux this returns `~/.config`, on macOS `~/Library/Application Support`.

    **load_config()** — Read the file with `std::fs::read_to_string()`, parse with `toml::from_str()`. Return `Result<FileConfig, Box<dyn std::error::Error>>`.

    Full implementation structure:

    ```rust
    use serde::Deserialize;
    use std::path::{Path, PathBuf};

    const DEFAULT_PORT: u16 = 8200;
    const DEFAULT_NAME: &str = "udlna";

    #[derive(Deserialize, Default, Debug)]
    pub struct FileConfig {
        pub port: Option<u16>,
        pub name: Option<String>,
    }

    #[derive(Debug)]
    pub struct Config {
        pub port: u16,
        pub name: String,
        pub paths: Vec<PathBuf>,
    }

    impl Config {
        pub fn resolve(file: Option<FileConfig>, args: &crate::cli::Args) -> Self {
            let file = file.unwrap_or_default();
            Config {
                port: args.port.or(file.port).unwrap_or(DEFAULT_PORT),
                name: args.name.clone().or(file.name).unwrap_or_else(|| DEFAULT_NAME.to_string()),
                paths: args.paths.clone(),
            }
        }
    }

    pub fn find_config_file(explicit: Option<&Path>) -> Option<PathBuf> {
        if let Some(path) = explicit {
            return Some(path.to_owned());
        }
        let cwd_config = PathBuf::from("udlna.toml");
        if cwd_config.exists() {
            return Some(cwd_config);
        }
        if let Some(config_dir) = dirs::config_dir() {
            let xdg_config = config_dir.join("udlna").join("config.toml");
            if xdg_config.exists() {
                return Some(xdg_config);
            }
        }
        None
    }

    pub fn load_config(path: &Path) -> Result<FileConfig, Box<dyn std::error::Error>> {
        let content = std::fs::read_to_string(path)?;
        let config: FileConfig = toml::from_str(&content)?;
        Ok(config)
    }
    ```

    Add unit tests in `#[cfg(test)]` block:

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        fn make_args(port: Option<u16>, name: Option<String>, paths: Vec<PathBuf>) -> crate::cli::Args {
            crate::cli::Args {
                port,
                name,
                paths,
                config: None,
            }
        }

        #[test]
        fn test_defaults_when_nothing_set() {
            let args = make_args(None, None, vec![PathBuf::from("/tmp")]);
            let config = Config::resolve(None, &args);
            assert_eq!(config.port, 8200);
            assert_eq!(config.name, "udlna");
        }

        #[test]
        fn test_cli_flag_overrides_default() {
            let args = make_args(Some(9000), None, vec![PathBuf::from("/tmp")]);
            let config = Config::resolve(None, &args);
            assert_eq!(config.port, 9000);
        }

        #[test]
        fn test_toml_overrides_default() {
            let file = FileConfig { port: Some(7777), name: None };
            let args = make_args(None, None, vec![PathBuf::from("/tmp")]);
            let config = Config::resolve(Some(file), &args);
            assert_eq!(config.port, 7777);
        }

        #[test]
        fn test_cli_overrides_toml() {
            let file = FileConfig { port: Some(7777), name: None };
            let args = make_args(Some(9000), None, vec![PathBuf::from("/tmp")]);
            let config = Config::resolve(Some(file), &args);
            assert_eq!(config.port, 9000); // CLI wins
        }

        #[test]
        fn test_toml_parse() {
            let toml_str = "port = 9000\nname = \"Living Room\"\n";
            let parsed: FileConfig = toml::from_str(toml_str).unwrap();
            assert_eq!(parsed.port, Some(9000));
            assert_eq!(parsed.name.as_deref(), Some("Living Room"));
        }

        #[test]
        fn test_toml_unknown_fields_ignored() {
            // Future keys must not break parsing
            let toml_str = "port = 9000\nunknown_future_key = true\n";
            let parsed: Result<FileConfig, _> = toml::from_str(toml_str);
            assert!(parsed.is_ok());
        }
    }
    ```
  </action>
  <verify>
    `cargo test config` runs and all 6 config tests pass.
    `cargo build` exits 0 with no errors.
  </verify>
  <done>
    src/config.rs implements FileConfig (serde Deserialize, all Option&lt;T&gt; fields, no deny_unknown_fields), Config (resolved with concrete types), Config::resolve() with three-layer merge, find_config_file() with CWD-first XDG search, load_config() using toml::from_str(). All 6 unit tests pass. Forward-compatibility test (unknown TOML key) passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire main.rs — logging, CLI parse, config load, path validation, startup banner</name>
  <files>src/main.rs</files>
  <action>
    Replace the stub src/main.rs with the complete entry point. This wires together all Phase 1 modules.

    **Step order in main():**
    1. Initialize tracing subscriber (first — before any other code that might log)
    2. Parse CLI args with `cli::Args::parse()`
    3. Find and load config file (using config::find_config_file + config::load_config)
    4. Merge into resolved Config via Config::resolve()
    5. Validate each path in config.paths — error-and-exit if not a directory that exists
    6. Print startup banner via tracing::info!

    **Tracing init:** Use env-filter with `info` as the default level. Do not add a `--log-level` CLI flag — use `RUST_LOG` env var exclusively:
    ```rust
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();
    ```

    **Config file loading:** If the config file fails to parse (malformed TOML), log a warning and continue with defaults (do not exit — a broken config file should not prevent startup when the user passed paths on CLI):
    ```rust
    let file_config = config::find_config_file(args.config.as_deref())
        .and_then(|path| {
            match config::load_config(&path) {
                Ok(cfg) => {
                    tracing::debug!("Loaded config from {}", path.display());
                    Some(cfg)
                }
                Err(e) => {
                    tracing::warn!("Failed to parse config file: {}", e);
                    None
                }
            }
        });
    ```

    **Path validation:** Error-and-exit (fail fast) for paths that don't exist or aren't directories. Use `eprintln!` for the error (not tracing, since this is a fatal user error), then `std::process::exit(1)`:
    ```rust
    for path in &config.paths {
        if !path.exists() {
            eprintln!("error: path does not exist: {}", path.display());
            std::process::exit(1);
        }
        if !path.is_dir() {
            eprintln!("error: not a directory: {}", path.display());
            std::process::exit(1);
        }
    }
    ```

    **Startup banner** (tracing::info! calls):
    ```
    udlna v{CARGO_PKG_VERSION}
    Serving {N} path(s) on port {port}
      {path1}
      {path2}
    Server name: "{name}"
    Ready. (Phase 1 complete — add Phase 2 for media scanning)
    ```

    Full main.rs:
    ```rust
    use clap::Parser;

    mod cli;
    mod config;
    mod media;

    fn main() {
        tracing_subscriber::fmt()
            .with_env_filter(
                tracing_subscriber::EnvFilter::try_from_default_env()
                    .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
            )
            .init();

        let args = cli::Args::parse();

        let file_config = config::find_config_file(args.config.as_deref())
            .and_then(|path| {
                match config::load_config(&path) {
                    Ok(cfg) => {
                        tracing::debug!("Loaded config from {}", path.display());
                        Some(cfg)
                    }
                    Err(e) => {
                        tracing::warn!("Failed to parse config file: {}", e);
                        None
                    }
                }
            });

        let config = config::Config::resolve(file_config, &args);

        for path in &config.paths {
            if !path.exists() {
                eprintln!("error: path does not exist: {}", path.display());
                std::process::exit(1);
            }
            if !path.is_dir() {
                eprintln!("error: not a directory: {}", path.display());
                std::process::exit(1);
            }
        }

        tracing::info!("udlna v{}", env!("CARGO_PKG_VERSION"));
        tracing::info!("Serving {} path(s) on port {}", config.paths.len(), config.port);
        for path in &config.paths {
            tracing::info!("  {}", path.display());
        }
        tracing::info!("Server name: \"{}\"", config.name);
        tracing::info!("Ready. (Phase 1 complete — add Phase 2 for media scanning)");
    }
    ```
  </action>
  <verify>
    `cargo build` exits 0 with no errors or warnings (fix any `unused import` or `dead_code` warnings — use `#[allow(dead_code)]` on MediaKind and classify if needed, since they are not called yet from main).
    `cargo run -- /tmp` prints startup banner with port 8200 and path /tmp.
    `cargo run -- /nonexistent_path_xyz` exits 1 with "error: path does not exist" message.
    `cargo run -- --port 9000 /tmp` shows port 9000 in the startup banner.
    `cargo test` passes all tests (MIME tests + config tests = 13 total).
    `cargo run` with no arguments prints help (arg_required_else_help = true).
  </verify>
  <done>
    src/main.rs wires all Phase 1 modules: tracing init, clap parse, config file search, three-layer merge, path validation (error-and-exit for bad paths), and startup banner via tracing::info!. `cargo build` exits 0 with no warnings. All 5 phase success criteria are verifiable. `cargo test` passes all 13 tests (7 MIME + 6 config).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0 with no warnings
2. `cargo test` exits 0 — 13 tests pass (7 MIME + 6 config)
3. `cargo run -- /tmp` prints startup banner showing port 8200 and path /tmp
4. `cargo run -- --port 9000 /tmp` shows port 9000
5. `cargo run -- /nonexistent_path_xyz` exits 1 with clear error message
6. Create a temp `udlna.toml` with `port = 7777`, run `cargo run -- /tmp`, observe port 7777 in output (TOML loaded)
7. With same `udlna.toml`, run `cargo run -- --port 9000 /tmp`, observe port 9000 (CLI overrides TOML)
8. `cargo run` with no arguments prints help text (not panic, not silent exit)
</verification>

<success_criteria>
- `cargo build` and `cargo test` both exit 0
- All 5 phase success criteria from ROADMAP.md are verifiable via CLI invocations
- Three-layer config merge works (defaults -> TOML -> CLI flags) as proven by tests and manual invocations
- No networking, no scanning, no server socket — Phase 1 scope only
- Binary is named `udlna` and responds to `udlna --help`
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-cli/01-02-SUMMARY.md` following the summary template.
</output>
