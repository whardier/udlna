---
phase: 08-server-identity-customization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config.rs
  - src/http/state.rs
  - src/http/soap.rs
  - src/ssdp/socket.rs
  - src/main.rs
  - src/http/description.rs
  - src/ssdp/service.rs
autonomous: true
requirements: [CLI-08, DISC-05]

must_haves:
  truths:
    - "Running udlna without --name produces a friendly name of the form 'udlna@{hostname}' in the startup banner and in device.xml"
    - "Running udlna --name 'Living Room Server' shows 'Living Room Server' as the friendlyName in device.xml"
    - "The server UUID is identical across multiple restarts on the same machine (derived from hostname, not random)"
    - "The startup banner shows both the friendly name and the UUID: udlna \"<name>\" (uuid: <uuid>) on port <port>"
    - "cargo build --release produces zero compiler warnings"
  artifacts:
    - path: "Cargo.toml"
      provides: "hostname crate 0.4.2 dependency"
      contains: "hostname"
    - path: "src/config.rs"
      provides: "Dynamic default_name() computing udlna@{hostname}"
      contains: "fn default_name"
    - path: "src/http/state.rs"
      provides: "AppState with server_name field"
      contains: "server_name: String"
    - path: "src/main.rs"
      provides: "UUID v5 derivation from hostname + server_name wired into AppState + startup banner"
      contains: "build_server_uuid"
    - path: "src/http/description.rs"
      provides: "friendlyName from state.server_name (xml_escaped)"
      contains: "server_name"
    - path: "src/ssdp/service.rs"
      provides: "SsdpConfig with server_name, logged at startup"
      contains: "server_name"
  key_links:
    - from: "src/main.rs"
      to: "src/http/state.rs"
      via: "AppState { server_name: config.name.clone() }"
      pattern: "server_name.*config\\.name"
    - from: "src/http/description.rs"
      to: "src/http/soap.rs"
      via: "xml_escape(&state.server_name)"
      pattern: "xml_escape.*server_name"
    - from: "src/main.rs"
      to: "src/config.rs"
      via: "Config::resolve uses default_name() for fallback"
      pattern: "default_name"
---

<objective>
Deliver Phase 8: stable server identity via UUID v5 (hostname-derived) and user-customizable friendly server name via --name flag, wired through device.xml and SSDP. Also eliminates two existing Rust compiler warnings. This is the final phase of v1.

Purpose: DLNA clients (Samsung TV, Xbox) see the user's chosen server name on their device lists; the server UUID stays stable across restarts so cached clients don't lose the server.
Output: Zero-warning Rust binary with stable UUID, dynamic default name, --name flag wired end-to-end through device.xml and SSDP startup log.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-server-identity-customization/08-CONTEXT.md
@.planning/phases/08-server-identity-customization/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hostname crate, update config.rs default name, fix compiler warnings</name>
  <files>
    Cargo.toml
    src/config.rs
    src/http/state.rs
    src/http/soap.rs
    src/ssdp/socket.rs
  </files>
  <action>
**Cargo.toml:** Add the `hostname` crate dependency (version 0.4.2) to `[dependencies]`. The `uuid` crate is already present with `v4` and `v5` features — no change needed there.

```toml
hostname = "0.4.2"
```

**src/config.rs:** Replace the static `DEFAULT_NAME: &str = "udlna"` constant with a dynamic `default_name()` function that computes `"udlna@{hostname}"`. Use the `hostname` crate for OS hostname acquisition.

Remove:
```rust
const DEFAULT_NAME: &str = "udlna";
```

Add at the top of the file (after `use` statements):
```rust
fn default_name() -> String {
    let host = hostname::get()
        .ok()
        .and_then(|os| os.into_string().ok())
        .filter(|s| !s.is_empty())
        .unwrap_or_default();
    if host.is_empty() {
        "udlna".to_string()
    } else {
        format!("udlna@{}", host)
    }
}
```

In `Config::resolve`, change the `name` field assignment from:
```rust
name: args.name.clone().or(file.name).unwrap_or_else(|| DEFAULT_NAME.to_string()),
```
to:
```rust
name: args.name.clone().or(file.name).unwrap_or_else(default_name),
```

Also update the existing test `test_defaults_when_nothing_set` — the assertion `assert_eq!(config.name, "udlna")` will now fail because the default is `"udlna@{hostname}"`. Change it to:
```rust
assert!(
    config.name == "udlna" || config.name.starts_with("udlna@"),
    "expected default name to be 'udlna' or 'udlna@<hostname>', got: {}",
    config.name
);
```

**src/http/state.rs:** Add `server_name: String` field to `AppState`. Update the comment on `server_uuid` to reflect Phase 8 status.

```rust
#[derive(Clone)]
pub struct AppState {
    pub library: Arc<RwLock<MediaLibrary>>,
    pub server_uuid: String,   // Stable UUID v5 derived from hostname (Phase 8)
    pub server_name: String,   // Friendly name from --name / config / default (Phase 8)
}
```

**src/http/soap.rs (line ~190):** Fix the lifetime annotation warning by changing the return type of `xml_escape`:
- Before: `pub fn xml_escape(s: &str) -> Cow<str>`
- After: `pub fn xml_escape(s: &str) -> Cow<'_, str>`

This is exactly the fix the compiler suggests. No logic change — just the explicit elided lifetime marker.

**src/ssdp/socket.rs:** Fix the unused `index` field warning in `IfaceV4` by adding `#[allow(dead_code)]` on the field. The field is intentionally kept for future IPv6 multicast use.

```rust
pub struct IfaceV4 {
    pub addr: Ipv4Addr,
    pub mask: Ipv4Addr,
    #[allow(dead_code)]
    pub index: u32,
}
```
  </action>
  <verify>
Run `cargo build 2>&1 | grep -E "^error|warning\[" | head -20`. Expected: no output (zero errors, zero warnings). Also confirm the new field compiles: `cargo check 2>&1 | tail -5` should show "Finished" with no warnings.

Run `cargo test config 2>&1 | tail -10`. Expected: all config tests pass (including the updated `test_defaults_when_nothing_set`).
  </verify>
  <done>
`cargo build` produces zero errors and zero warnings. `cargo test config` shows all config tests passing. The `AppState` struct now has a `server_name: String` field. The `xml_escape` function returns `Cow<'_, str>`. The `IfaceV4.index` field has `#[allow(dead_code)]`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire UUID v5 and server_name through main.rs, description.rs, and ssdp/service.rs</name>
  <files>
    src/main.rs
    src/http/description.rs
    src/ssdp/service.rs
  </files>
  <action>
**src/main.rs:**

1. Add a `build_server_uuid` helper function (inline in main.rs, before `main()`). It derives a UUID v5 from the hostname using `Uuid::NAMESPACE_DNS` — mirroring the existing `build_machine_namespace()` pattern in `src/media/metadata.rs`:

```rust
fn build_server_uuid(hostname: &str) -> String {
    uuid::Uuid::new_v5(&uuid::Uuid::NAMESPACE_DNS, hostname.as_bytes()).to_string()
}
```

2. Add a `get_hostname()` helper that acquires the hostname safely:

```rust
fn get_hostname() -> String {
    hostname::get()
        .ok()
        .and_then(|os| os.into_string().ok())
        .filter(|s| !s.is_empty())
        .unwrap_or_else(|| "udlna".to_string())
}
```

3. In `main()`, BEFORE the startup banner log, compute the hostname and server UUID:

```rust
let raw_hostname = get_hostname();
let server_uuid = build_server_uuid(&raw_hostname);
```

Move this before the `tracing::info!("udlna v{}...`)` banner line. The current code computes UUID later at line 92 — move the UUID derivation up so the banner can show it.

4. Replace the existing startup banner log (currently at line 73 and 77):
```rust
// Remove these two lines:
tracing::info!("udlna v{} -- scanning media directories...", env!("CARGO_PKG_VERSION"));
// ...
tracing::info!("Server name: \"{}\"", config.name);

// Replace with one banner line (after config is resolved and UUID is computed):
tracing::info!(
    "udlna \"{}\" (uuid: {}) on port {}",
    config.name,
    server_uuid,
    config.port
);
tracing::info!("Scanning media directories:");
for path in &config.paths {
    tracing::info!("  {}", path.display());
}
```

5. Remove the old `let server_uuid = uuid::Uuid::new_v4().to_string();` line (currently line 92).

6. Update the `AppState` construction (currently line 93-96) to include `server_name`:
```rust
let state = http::state::AppState {
    library: Arc::clone(&library),
    server_uuid: server_uuid.clone(),
    server_name: config.name.clone(),
};
```

7. Ensure `use hostname;` is not needed at the top level since the helpers are module-local functions calling `hostname::get()`. The `hostname` crate is in Cargo.toml; Rust will resolve it without an explicit `use` in the function body (or add `use hostname;` at the top of main.rs if needed for clarity).

**src/http/description.rs:**

Replace the hardcoded `<friendlyName>udlna</friendlyName>` with the value from `state.server_name`, XML-escaped for safety. Import `xml_escape` from soap.rs.

In `serve_device_xml`, the format string currently uses only `uuid = state.server_uuid`. Add `name`:

```rust
pub async fn serve_device_xml(State(state): State<AppState>) -> impl IntoResponse {
    let friendly_name = crate::http::soap::xml_escape(&state.server_name);
    let body = format!(r#"<?xml version="1.0" encoding="utf-8"?>
<root xmlns="urn:schemas-upnp-org:device-1-0"
      xmlns:dlna="urn:schemas-dlna-org:device-1-0">
  ...
    <friendlyName>{name}</friendlyName>
  ...
"#, uuid = state.server_uuid, name = friendly_name);
```

Preserve the full XML template unchanged except replacing `<friendlyName>udlna</friendlyName>` with `<friendlyName>{name}</friendlyName>` and adding `name = friendly_name` to the format args.

**src/ssdp/service.rs:**

Add `server_name: String` to `SsdpConfig`:
```rust
pub struct SsdpConfig {
    pub device_uuid: String,
    pub http_port: u16,
    pub server_name: String,   // Friendly name for startup log (Phase 8)
}
```

Update the startup log line (currently `"SSDP advertising on {}:1900"`) to include the server name:
```rust
for iface in &ifaces {
    tracing::info!("SSDP advertising \"{}\" on {}:1900", config.server_name, iface.addr);
}
```

Update both `SsdpConfig` construction sites in `main.rs` (one in the `config.localhost` branch, one in the dual-bind branch) to include `server_name`:
```rust
let ssdp_config = ssdp::service::SsdpConfig {
    device_uuid: server_uuid.clone(),
    http_port: config.port,
    server_name: config.name.clone(),
};
```

Note: There are TWO `SsdpConfig` construction sites in main.rs (localhost path and dual-bind path). Update BOTH.
  </action>
  <verify>
Run `cargo build --release 2>&1 | grep -E "^error|^warning\[" | head -20`. Expected: zero output (zero errors, zero warnings in release build).

Run the server briefly and check output:
```bash
cargo run -- /tmp 2>&1 | head -10
```
Expected log output includes a line like: `udlna "udlna@macbook" (uuid: xxxxxxxx-...) on port 8200`

Run with --name flag:
```bash
cargo run -- --name "Living Room" /tmp 2>&1 | head -10
```
Expected: banner shows `udlna "Living Room" (uuid: ...) on port 8200` and SSDP log shows `SSDP advertising "Living Room" on ...`.

Check UUID stability (run twice, compare UUIDs):
```bash
cargo run -- /tmp 2>&1 | grep uuid &
sleep 2 && kill %1
cargo run -- /tmp 2>&1 | grep uuid &
sleep 2 && kill %1
```
Both runs should show the SAME uuid value (derived from hostname, not random).

Verify device.xml friendlyName:
```bash
# Start server in background, curl device.xml, kill server
cargo run -- /tmp &
SERVER_PID=$!
sleep 3
curl -s http://localhost:8200/device.xml | grep friendlyName
kill $SERVER_PID 2>/dev/null
```
Expected: `<friendlyName>udlna@macbook</friendlyName>` (or the actual hostname).
  </verify>
  <done>
`cargo build --release` shows zero warnings and zero errors. The startup banner includes both the friendly name and the UUID. The UUID is identical across two consecutive runs (derived from hostname). `curl http://localhost:8200/device.xml` returns `<friendlyName>` with the resolved server name. Running with `--name "Living Room"` shows "Living Room" in the banner and in device.xml.
  </done>
</task>

</tasks>

<verification>
Final phase verification checklist:

1. `cargo build --release 2>&1 | grep -c "^warning\["` returns 0 (zero warnings)
2. `cargo test 2>&1 | tail -5` shows all tests passing
3. Server started without --name: banner shows `udlna "udlna@<hostname>"` form
4. Server started with `--name "Test Name"`: banner shows `udlna "Test Name"`, device.xml has `<friendlyName>Test Name</friendlyName>`
5. UUID from two separate runs of `cargo run -- /tmp 2>&1 | grep uuid` is identical
6. `cargo run -- /tmp 2>&1 | grep "SSDP advertising"` shows the server name in the SSDP log line
7. `src/http/soap.rs` xml_escape returns `Cow<'_, str>` (compiler confirmed via zero warnings)
8. `src/ssdp/socket.rs` IfaceV4.index has `#[allow(dead_code)]` (compiler confirmed via zero warnings)
</verification>

<success_criteria>
Phase 8 is complete when:
- Zero Rust compiler warnings (`cargo build --release` produces clean output)
- All existing tests pass (`cargo test`)
- UUID v5 is derived from hostname using `Uuid::NAMESPACE_DNS` — confirmed stable across restarts
- `--name "Custom Name"` causes "Custom Name" to appear in device.xml `<friendlyName>` and startup banner
- Default name when --name is absent is `"udlna@{hostname}"` (e.g., `"udlna@macbook"`)
- Startup banner logs both name and UUID on a single line
- SSDP advertising log includes the server name
- DISC-05: Friendly name appears as `<friendlyName>` in device.xml served to DLNA clients
- CLI-08: UUID v5 derived from hostname using DNS namespace — consistent across restarts, no state file required
</success_criteria>

<output>
After completion, create `.planning/phases/08-server-identity-customization/08-01-SUMMARY.md` with:
- What was built (files changed, key decisions made)
- Actual implementation notes (any deviations from the plan)
- Verification results (cargo build output, test results, curl output for device.xml)
- Final project state (v1 milestone complete)
</output>