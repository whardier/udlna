---
phase: 04-device-service-description
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/http/state.rs
  - src/http/description.rs
  - src/http/mod.rs
  - src/main.rs
autonomous: true
requirements:
  - DESC-01
  - DESC-02
  - DESC-03

must_haves:
  truths:
    - "GET /device.xml returns text/xml with MediaServer:1 device type, dlna:X_DLNADOC, and both service declarations"
    - "GET /cds/scpd.xml returns text/xml with all 4 ContentDirectory actions and complete serviceStateTable"
    - "GET /cms/scpd.xml returns text/xml with all 3 ConnectionManager actions and complete serviceStateTable"
    - "cargo build --release succeeds with no errors or warnings"
  artifacts:
    - path: "src/http/description.rs"
      provides: "Three axum handlers: serve_device_xml, serve_cds_scpd, serve_cms_scpd"
      min_lines: 80
    - path: "src/http/state.rs"
      provides: "AppState with server_uuid: String field"
      contains: "server_uuid"
    - path: "src/http/mod.rs"
      provides: "Router with description handlers replacing 501 stubs"
      contains: "description::serve_device_xml"
    - path: "src/main.rs"
      provides: "UUID v4 generation at startup, passed into AppState"
      contains: "server_uuid"
  key_links:
    - from: "src/main.rs"
      to: "src/http/state.rs"
      via: "AppState { library, server_uuid }"
      pattern: "server_uuid"
    - from: "src/http/mod.rs"
      to: "src/http/description.rs"
      via: "description::serve_device_xml in route handler"
      pattern: "description::serve_device_xml"
    - from: "src/http/description.rs"
      to: "src/http/state.rs"
      via: "State(state): State<AppState> in serve_device_xml"
      pattern: "State\\(state\\)"
---

<objective>
Implement UPnP device description and SCPD service description HTTP endpoints for Phase 4.

Purpose: DLNA clients fetch /device.xml to understand what the server offers, then fetch /cds/scpd.xml and /cms/scpd.xml to learn the service action signatures. These documents are required before any ContentDirectory or ConnectionManager SOAP calls can work. Phase 3 left 501 stubs at all three routes — this plan replaces them with correct, spec-compliant XML.

Output: src/http/description.rs (three handlers), updated AppState (server_uuid field), updated build_router (stubs replaced), updated main.rs (UUID generation). Binary compiles clean.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-device-service-description/04-RESEARCH.md
@src/http/state.rs
@src/http/mod.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AppState with server_uuid and generate UUID v4 at startup</name>
  <files>src/http/state.rs, src/main.rs</files>
  <action>
In src/http/state.rs, add `server_uuid: String` as a public field to AppState:

```rust
#[derive(Clone)]
pub struct AppState {
    pub library: Arc<RwLock<MediaLibrary>>,
    pub server_uuid: String,   // Phase 4: random UUID v4; Phase 8 replaces with stable UUIDv5
}
```

In src/main.rs, generate a UUID v4 at startup (after the scan, before AppState construction) and pass it in:

```rust
let server_uuid = uuid::Uuid::new_v4().to_string();
let state = http::state::AppState {
    library: Arc::clone(&library),
    server_uuid,
};
```

The uuid crate is already in Cargo.toml with v5 feature — v4 is included by default in uuid 1.x. If the build fails with "v4 feature not found", add features = ["v4", "v5"] to the uuid entry in Cargo.toml.

Do NOT add `base_url` to AppState in Phase 4. Per RESEARCH.md Pitfall 3 and Open Question 2: URLBase is omitted entirely; SCPDURL absolute paths (/cds/scpd.xml) are self-sufficient. Phase 5 will add any additional state fields it needs.

The UUID changes on every restart — this is acceptable for Phase 4 since SSDP is not yet implemented (Phase 6) and no client has cached the UDN.
  </action>
  <verify>cargo build 2>&1 | grep -E "^error" | head -20</verify>
  <done>cargo build succeeds with no errors. AppState has server_uuid field. main.rs generates UUID v4 before AppState construction.</done>
</task>

<task type="auto">
  <name>Task 2: Create description.rs with device.xml, cds/scpd.xml, and cms/scpd.xml handlers</name>
  <files>src/http/description.rs</files>
  <action>
Create src/http/description.rs with three handlers. The SCPD documents are fully static — define them as const &str. The device description requires UUID interpolation — generate via format!().

Key constraints from RESEARCH.md (all MUST be followed exactly):
- Content-Type header MUST be: `"text/xml; charset=\"utf-8\""` (not text/plain, not application/xml)
- UDN MUST be: `uuid:{uuid}` — the "uuid:" prefix is part of the UDN value, not the UUID itself
- serviceId MUST use: `urn:upnp-org:serviceId:ContentDirectory` and `urn:upnp-org:serviceId:ConnectionManager` (NOT urn:schemas-upnp-org — that's a known bug in PyMedS-ng)
- DLNA namespace MUST be declared on root element: `xmlns:dlna="urn:schemas-dlna-org:device-1-0"`
- URLBase MUST be omitted entirely (Pitfall 3: complex with dual-stack, deprecated in UPnP 1.1)
- eventSubURL element MUST be present but empty (missing it causes some clients to reject the service)
- presentationURL MUST be included as `<presentationURL>/</presentationURL>`

**serve_device_xml handler** — uses State(state) to read server_uuid, returns formatted XML:

```rust
use axum::{extract::State, http::header, response::IntoResponse};
use crate::http::state::AppState;

pub async fn serve_device_xml(State(state): State<AppState>) -> impl IntoResponse {
    let body = format!(r#"<?xml version="1.0" encoding="utf-8"?>
<root xmlns="urn:schemas-upnp-org:device-1-0"
      xmlns:dlna="urn:schemas-dlna-org:device-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <device>
    <deviceType>urn:schemas-upnp-org:device:MediaServer:1</deviceType>
    <dlna:X_DLNADOC>DMS-1.50</dlna:X_DLNADOC>
    <dlna:X_DLNADOC>M-DMS-1.50</dlna:X_DLNADOC>
    <dlna:X_DLNACAP/>
    <friendlyName>udlna</friendlyName>
    <manufacturer>udlna project</manufacturer>
    <manufacturerURL>https://github.com/</manufacturerURL>
    <modelDescription>Minimal DLNA/UPnP Media Server</modelDescription>
    <modelName>udlna</modelName>
    <modelNumber>0.1</modelNumber>
    <modelURL>https://github.com/</modelURL>
    <serialNumber>0</serialNumber>
    <UDN>uuid:{uuid}</UDN>
    <presentationURL>/</presentationURL>
    <serviceList>
      <service>
        <serviceType>urn:schemas-upnp-org:service:ContentDirectory:1</serviceType>
        <serviceId>urn:upnp-org:serviceId:ContentDirectory</serviceId>
        <SCPDURL>/cds/scpd.xml</SCPDURL>
        <controlURL>/cds/control</controlURL>
        <eventSubURL></eventSubURL>
      </service>
      <service>
        <serviceType>urn:schemas-upnp-org:service:ConnectionManager:1</serviceType>
        <serviceId>urn:upnp-org:serviceId:ConnectionManager</serviceId>
        <SCPDURL>/cms/scpd.xml</SCPDURL>
        <controlURL>/cms/control</controlURL>
        <eventSubURL></eventSubURL>
      </service>
    </serviceList>
  </device>
</root>"#, uuid = state.server_uuid);
    ([(header::CONTENT_TYPE, "text/xml; charset=\"utf-8\"")], body)
}
```

**serve_cds_scpd handler** — fully static, uses const:

```rust
const CDS_SCPD_XML: &str = r#"<?xml version="1.0" encoding="utf-8"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion><major>1</major><minor>0</minor></specVersion>
  <actionList>
    <action>
      <name>Browse</name>
      <argumentList>
        <argument><name>ObjectID</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable></argument>
        <argument><name>BrowseFlag</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_BrowseFlag</relatedStateVariable></argument>
        <argument><name>Filter</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_Filter</relatedStateVariable></argument>
        <argument><name>StartingIndex</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_Index</relatedStateVariable></argument>
        <argument><name>RequestedCount</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable></argument>
        <argument><name>SortCriteria</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_SortCriteria</relatedStateVariable></argument>
        <argument><name>Result</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_Result</relatedStateVariable></argument>
        <argument><name>NumberReturned</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable></argument>
        <argument><name>TotalMatches</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable></argument>
        <argument><name>UpdateID</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_UpdateID</relatedStateVariable></argument>
      </argumentList>
    </action>
    <action>
      <name>GetSearchCapabilities</name>
      <argumentList>
        <argument><name>SearchCaps</name><direction>out</direction><relatedStateVariable>SearchCapabilities</relatedStateVariable></argument>
      </argumentList>
    </action>
    <action>
      <name>GetSortCapabilities</name>
      <argumentList>
        <argument><name>SortCaps</name><direction>out</direction><relatedStateVariable>SortCapabilities</relatedStateVariable></argument>
      </argumentList>
    </action>
    <action>
      <name>GetSystemUpdateID</name>
      <argumentList>
        <argument><name>Id</name><direction>out</direction><relatedStateVariable>SystemUpdateID</relatedStateVariable></argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_BrowseFlag</name><dataType>string</dataType><allowedValueList><allowedValue>BrowseMetadata</allowedValue><allowedValue>BrowseDirectChildren</allowedValue></allowedValueList></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_SearchCriteria</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="yes"><name>SystemUpdateID</name><dataType>ui4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_Count</name><dataType>ui4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_SortCriteria</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>SortCapabilities</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_Index</name><dataType>ui4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_ObjectID</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_UpdateID</name><dataType>ui4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_Result</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>SearchCapabilities</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_Filter</name><dataType>string</dataType></stateVariable>
  </serviceStateTable>
</scpd>"#;

pub async fn serve_cds_scpd() -> impl IntoResponse {
    ([(header::CONTENT_TYPE, "text/xml; charset=\"utf-8\"")], CDS_SCPD_XML)
}
```

**serve_cms_scpd handler** — fully static, uses const:

```rust
const CMS_SCPD_XML: &str = r#"<?xml version="1.0" encoding="utf-8"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion><major>1</major><minor>0</minor></specVersion>
  <actionList>
    <action>
      <name>GetProtocolInfo</name>
      <argumentList>
        <argument><name>Source</name><direction>out</direction><relatedStateVariable>SourceProtocolInfo</relatedStateVariable></argument>
        <argument><name>Sink</name><direction>out</direction><relatedStateVariable>SinkProtocolInfo</relatedStateVariable></argument>
      </argumentList>
    </action>
    <action>
      <name>GetCurrentConnectionIDs</name>
      <argumentList>
        <argument><name>ConnectionIDs</name><direction>out</direction><relatedStateVariable>CurrentConnectionIDs</relatedStateVariable></argument>
      </argumentList>
    </action>
    <action>
      <name>GetCurrentConnectionInfo</name>
      <argumentList>
        <argument><name>ConnectionID</name><direction>in</direction><relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable></argument>
        <argument><name>RcsID</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_RcsID</relatedStateVariable></argument>
        <argument><name>AVTransportID</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_AVTransportID</relatedStateVariable></argument>
        <argument><name>ProtocolInfo</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_ProtocolInfo</relatedStateVariable></argument>
        <argument><name>PeerConnectionManager</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_ConnectionManager</relatedStateVariable></argument>
        <argument><name>PeerConnectionID</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable></argument>
        <argument><name>Direction</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_Direction</relatedStateVariable></argument>
        <argument><name>Status</name><direction>out</direction><relatedStateVariable>A_ARG_TYPE_ConnectionStatus</relatedStateVariable></argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_ProtocolInfo</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_ConnectionStatus</name><dataType>string</dataType><allowedValueList><allowedValue>OK</allowedValue><allowedValue>ContentFormatMismatch</allowedValue><allowedValue>InsufficientBandwidth</allowedValue><allowedValue>UnreliableChannel</allowedValue><allowedValue>Unknown</allowedValue></allowedValueList></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_AVTransportID</name><dataType>i4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_RcsID</name><dataType>i4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_ConnectionID</name><dataType>i4</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_ConnectionManager</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="yes"><name>SourceProtocolInfo</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="yes"><name>SinkProtocolInfo</name><dataType>string</dataType></stateVariable>
    <stateVariable sendEvents="no"><name>A_ARG_TYPE_Direction</name><dataType>string</dataType><allowedValueList><allowedValue>Input</allowedValue><allowedValue>Output</allowedValue></allowedValueList></stateVariable>
    <stateVariable sendEvents="yes"><name>CurrentConnectionIDs</name><dataType>string</dataType></stateVariable>
  </serviceStateTable>
</scpd>"#;

pub async fn serve_cms_scpd() -> impl IntoResponse {
    ([(header::CONTENT_TYPE, "text/xml; charset=\"utf-8\"")], CMS_SCPD_XML)
}
```

The three handlers in the file should appear in this order: constants first (CDS_SCPD_XML, CMS_SCPD_XML at top), then serve_device_xml, serve_cds_scpd, serve_cms_scpd. Add `use axum::{extract::State, http::header, response::IntoResponse};` and `use crate::http::state::AppState;` imports.

Do NOT use an XML builder crate — the XML is almost entirely static and string templates are more readable. Do NOT use lazy_static or once_cell — format!() per call is fine for Phase 4 since the UUID does not change between requests.
  </action>
  <verify>cargo build 2>&1 | grep -E "^error" | head -20</verify>
  <done>cargo build succeeds. src/http/description.rs exists with three handlers. All SCPD state variables referenced in relatedStateVariable have corresponding stateVariable entries in serviceStateTable.</done>
</task>

<task type="auto">
  <name>Task 3: Wire description handlers into build_router, replacing Phase 4 stubs</name>
  <files>src/http/mod.rs</files>
  <action>
In src/http/mod.rs, add `pub mod description;` to the module declarations. Then replace the three Phase 4 501 stub closures with the description handlers:

```rust
pub mod media;
pub mod state;
pub mod description;

use axum::{routing::get, Router};
use tower_http::trace::TraceLayer;
use crate::http::state::AppState;

pub fn build_router(state: AppState) -> Router {
    Router::new()
        // Phase 3 — implemented in media.rs
        .route("/media/{id}", get(media::serve_media_get).head(media::serve_media_head))
        // Phase 4 — device and service description XML
        .route("/device.xml", get(description::serve_device_xml))
        .route("/cds/scpd.xml", get(description::serve_cds_scpd))
        .route("/cms/scpd.xml", get(description::serve_cms_scpd))
        // Phase 5 stubs — SOAP control endpoints (still 501)
        .route("/cds/control", axum::routing::post(|| async {
            (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
        }))
        .route("/cms/control", axum::routing::post(|| async {
            (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
        }))
        .layer(TraceLayer::new_for_http())
        .with_state(state)
}
```

The Phase 5 stubs at /cds/control and /cms/control MUST remain — they are needed for Phase 5 and Phase 7 respectively. Only the three description stubs are replaced.

After editing, run `cargo build --release` to confirm the full release build compiles clean (not just debug). The release build is what ships.
  </action>
  <verify>cargo build --release 2>&1 | tail -5</verify>
  <done>cargo build --release succeeds. src/http/mod.rs declares `pub mod description` and routes /device.xml, /cds/scpd.xml, /cms/scpd.xml to description::serve_* handlers. Phase 5 stubs at /cds/control and /cms/control remain intact.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build --release` passes with no errors
2. `cargo clippy -- -D warnings` passes (or any warnings are understood and acceptable)
3. `grep -r "server_uuid" src/` shows occurrences in state.rs, main.rs, and description.rs
4. `grep "description::" src/http/mod.rs` shows all three handler registrations
5. The SCPD XML in description.rs contains `urn:upnp-org:serviceId:ContentDirectory` (correct) not `urn:schemas-upnp-org:serviceId:ContentDirectory` (wrong)
</verification>

<success_criteria>
- cargo build --release succeeds with no errors
- src/http/description.rs exists with serve_device_xml, serve_cds_scpd, serve_cms_scpd
- AppState.server_uuid: String field exists and is populated from Uuid::new_v4() in main.rs
- /device.xml route returns description::serve_device_xml (not 501 stub)
- /cds/scpd.xml and /cms/scpd.xml routes return description::serve_cds_scpd / serve_cms_scpd
- /cds/control and /cms/control Phase 5 stubs still return 501
</success_criteria>

<output>
After completion, create `.planning/phases/04-device-service-description/04-01-SUMMARY.md`
</output>
