---
phase: 03-http-server-file-streaming
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/http/media.rs
autonomous: true
requirements:
  - STRM-01
  - STRM-02
  - STRM-03
  - STRM-04
  - STRM-05
  - STRM-06

must_haves:
  truths:
    - "GET /media/{id} with valid UUID returns 200 with correct Content-Type from MediaItem.mime"
    - "GET /media/{id} with Range: bytes=0-99 header returns 206 Partial Content with Content-Range: bytes 0-99/{total}"
    - "GET /media/{id} with unsatisfiable range returns 416 with Content-Range: bytes */{total}"
    - "HEAD /media/{id} returns 200 with all DLNA headers and Content-Length but no body (no file open)"
    - "All media responses include Accept-Ranges: bytes header"
    - "All media responses include transferMode.dlna.org: Streaming header"
    - "All media responses include contentFeatures.dlna.org with DLNA.ORG_OP=01 and 32-char DLNA.ORG_FLAGS"
    - "GET /media/{unknown-uuid} returns 404 with empty body"
    - "GET /media/not-a-uuid returns 404 with empty body (not 400)"
    - "File missing at serve time returns 500 with tracing::error! log"
  artifacts:
    - path: "src/http/media.rs"
      provides: "serve_media_get and serve_media_head handlers with full Range support and DLNA headers"
      min_lines: 80
      exports: ["serve_media_get", "serve_media_head"]
  key_links:
    - from: "src/http/media.rs"
      to: "src/media/library.rs"
      via: "State<AppState> -> library.read().unwrap().items.iter().find()"
      pattern: "library\\.read"
    - from: "src/http/media.rs"
      to: "tokio::fs::File"
      via: "tokio::fs::File::open(&item.path).await"
      pattern: "tokio::fs::File::open"
    - from: "src/http/media.rs"
      to: "http_range_header"
      via: "parse_range_header(range_str).validate(file_size)"
      pattern: "parse_range_header"
---

<objective>
Implement the complete `/media/{id}` handler in `src/http/media.rs` — replacing the Plan 01 stub with real GET (full + range) and HEAD handlers with all required DLNA response headers.

Purpose: This is the core DLNA streaming capability. All 6 streaming requirements are satisfied here.
Output: src/http/media.rs with production-quality GET (RFC 7233 Range-aware) and HEAD handlers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-server-file-streaming/03-CONTEXT.md
@.planning/phases/03-http-server-file-streaming/03-RESEARCH.md
@.planning/phases/03-http-server-file-streaming/03-01-SUMMARY.md

@src/http/media.rs
@src/http/state.rs
@src/http/mod.rs
@src/media/library.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement serve_media_head — headers-only response without file open</name>
  <files>src/http/media.rs</files>
  <action>
    Replace the stub `serve_media_head` with a real implementation. HEAD looks up the MediaItem from the library, builds all DLNA headers, and returns 200 with no body — without opening the file.

    **Why separate HEAD handler (not axum auto-strip):** Samsung TV sends HEAD before every GET. axum's automatic HEAD-from-GET behavior runs the full GET handler and then strips the body, which means every HEAD causes a file open. The explicit HEAD handler avoids the unnecessary disk I/O.

    Implementation:

    ```rust
    use axum::{
        extract::{Path, State},
        http::{HeaderMap, HeaderName, HeaderValue, StatusCode},
        response::{IntoResponse, Response},
        body::Body,
    };
    use axum_extra::response::file_stream::FileStream;
    use http_range_header::parse_range_header;
    use tokio_util::io::ReaderStream;
    use uuid::Uuid;
    use crate::http::state::AppState;
    use crate::media::library::MediaItem;

    // DLNA header constants — values per DLNA spec and cross-verified with working DLNA servers
    // DLNA.ORG_OP=01: byte seek supported (bit 0), time seek not supported (bit 1)
    // DLNA.ORG_CI=0: content is not converted/transcoded
    // DLNA.ORG_FLAGS: 32 hex chars (8 significant + 24 zero padding, required length)
    //   01700000 = STREAMING_TRANSFER_MODE | BACKGROUND_TRANSFER_MODE | CONNECTION_STALL | DLNA_V15
    const DLNA_CONTENT_FEATURES: &str =
        "DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000";
    const DLNA_TRANSFER_MODE: &str = "Streaming";

    /// Look up MediaItem by UUID string. Returns None if UUID is invalid or item not found.
    /// Lock is acquired and released within this function — safe to call before any .await.
    fn lookup_item(state: &AppState, id_str: &str) -> Option<MediaItem> {
        let id = Uuid::parse_str(id_str).ok()?;
        let lib = state.library.read().unwrap();
        lib.items.iter().find(|i| i.id == id).cloned()
    }

    /// Build the standard DLNA response headers present on ALL media responses (GET + HEAD).
    /// Returns a HeaderMap with: Content-Type, Content-Length, Accept-Ranges,
    /// transferMode.dlna.org, contentFeatures.dlna.org.
    fn dlna_headers(item: &MediaItem) -> HeaderMap {
        let mut headers = HeaderMap::new();
        headers.insert(
            axum::http::header::CONTENT_TYPE,
            HeaderValue::from_str(item.mime).unwrap_or(HeaderValue::from_static("application/octet-stream")),
        );
        headers.insert(
            axum::http::header::CONTENT_LENGTH,
            HeaderValue::from(item.file_size),
        );
        headers.insert(
            axum::http::header::ACCEPT_RANGES,
            HeaderValue::from_static("bytes"),
        );
        headers.insert(
            HeaderName::from_static("transfermode.dlna.org"),
            HeaderValue::from_static(DLNA_TRANSFER_MODE),
        );
        headers.insert(
            HeaderName::from_static("contentfeatures.dlna.org"),
            HeaderValue::from_static(DLNA_CONTENT_FEATURES),
        );
        headers
    }

    pub async fn serve_media_head(
        State(state): State<AppState>,
        Path(id_str): Path<String>,
    ) -> Response {
        let item = match lookup_item(&state, &id_str) {
            Some(i) => i,
            None => return StatusCode::NOT_FOUND.into_response(),
        };
        // Return 200 with all DLNA headers and NO body. Do NOT open the file.
        (StatusCode::OK, dlna_headers(&item)).into_response()
    }
    ```

    Note on header name casing: HTTP/1.1 headers are case-insensitive. `HeaderName::from_static` accepts lowercase. Use lowercase `"transfermode.dlna.org"` and `"contentfeatures.dlna.org"` — these match the spec when sent on the wire.

    Note on `item.mime`: Check the MediaItem struct type for the `mime` field. From Phase 2, `mime` is `&'static str` (from classify()). Use `HeaderValue::from_static(item.mime)` if it is `&'static str`. If it is a `String`, use `HeaderValue::from_str(&item.mime)`.
  </action>
  <verify>
    cargo build exits 0.
    If a test media directory is available: `cargo run -- /path/to/media &amp; sleep 1 &amp;&amp; curl -sI http://localhost:8200/media/$(uuid) | grep -i "accept-ranges"` (server starts but handler returns 404 for unknown UUID — that is expected at this stage since main.rs is not wired yet in Plan 03).
    Unit check: `cargo test` passes all existing tests.
  </verify>
  <done>serve_media_head returns 200 with Content-Type, Content-Length, Accept-Ranges, transferMode.dlna.org, contentFeatures.dlna.org headers and no body for known item; returns 404 for unknown or malformed UUID</done>
</task>

<task type="auto">
  <name>Task 2: Implement serve_media_get — full file streaming and RFC 7233 Range support</name>
  <files>src/http/media.rs</files>
  <action>
    Add the full `serve_media_get` implementation. This handler must:
    1. Look up MediaItem (UUID parse fail → 404, unknown ID → 404)
    2. Check for `Range:` header
    3. If no Range header: open file, stream full body with 200
    4. If Range header present: parse with http-range-header, return 206 or 416
    5. If file cannot be opened: log tracing::error! and return 500

    **Full implementation:**

    ```rust
    pub async fn serve_media_get(
        State(state): State<AppState>,
        Path(id_str): Path<String>,
        req_headers: HeaderMap,
    ) -> Response {
        // Lookup (releases lock before any .await — avoids Send issue with RwLock guard)
        let item = match lookup_item(&state, &id_str) {
            Some(i) => i,
            None => return StatusCode::NOT_FOUND.into_response(),
        };

        let headers = dlna_headers(&item);

        // Check for Range header
        if let Some(range_val) = req_headers.get(axum::http::header::RANGE) {
            let range_str = match range_val.to_str() {
                Ok(s) => s.to_owned(),
                Err(_) => {
                    // Unparseable Range value → treat as unsatisfiable
                    return (
                        StatusCode::RANGE_NOT_SATISFIABLE,
                        [(
                            "content-range",
                            format!("bytes */{}", item.file_size),
                        )],
                    ).into_response();
                }
            };
            return range_response(&item, &range_str, headers).await;
        }

        // Full GET — stream entire file
        let file = match tokio::fs::File::open(&item.path).await {
            Ok(f) => f,
            Err(e) => {
                tracing::error!("Failed to open file {}: {}", item.path.display(), e);
                return StatusCode::INTERNAL_SERVER_ERROR.into_response();
            }
        };
        let stream = ReaderStream::new(file);
        let body = Body::from_stream(stream);
        (StatusCode::OK, headers, body).into_response()
    }

    /// Handle a Range request. Returns 206 Partial Content or 416 Range Not Satisfiable.
    /// Decision (CONTEXT.md): multi-part ranges → serve first range only; suffix ranges supported.
    async fn range_response(item: &MediaItem, range_str: &str, mut headers: HeaderMap) -> Response {
        // Parse Range header string (e.g., "bytes=0-99", "bytes=-500")
        let parsed = match parse_range_header(range_str) {
            Ok(p) => p,
            Err(_) => {
                return (
                    StatusCode::RANGE_NOT_SATISFIABLE,
                    [("content-range", format!("bytes */{}", item.file_size))],
                ).into_response();
            }
        };

        // Validate against actual file size (resolves suffix ranges to absolute positions)
        let ranges = match parsed.validate(item.file_size) {
            Ok(r) => r,
            Err(_) => {
                return (
                    StatusCode::RANGE_NOT_SATISFIABLE,
                    [("content-range", format!("bytes */{}", item.file_size))],
                ).into_response();
            }
        };

        // Take first range only (CONTEXT.md locked decision: multi-part → first range only)
        let first = match ranges.into_iter().next() {
            Some(r) => r,
            None => {
                return (
                    StatusCode::RANGE_NOT_SATISFIABLE,
                    [("content-range", format!("bytes */{}", item.file_size))],
                ).into_response();
            }
        };

        let start = first.start();
        let end = first.end(); // inclusive end byte

        // Use FileStream for 206 construction — handles correct Content-Range header and chunked delivery
        // FileStream::try_range_response opens file, seeks to start, returns Response
        match FileStream::try_range_response(&item.path, start, end).await {
            Ok(mut resp) => {
                // Insert DLNA headers into the 206 response (FileStream does not add them)
                for (name, value) in &headers {
                    resp.headers_mut().insert(name.clone(), value.clone());
                }
                resp
            }
            Err(e) => {
                tracing::error!("Range response failed for {}: {}", item.path.display(), e);
                StatusCode::INTERNAL_SERVER_ERROR.into_response()
            }
        }
    }
    ```

    **Note on http-range-header API:** At compile time, verify the exact method names on the validated range type. The crate is small; the method names are likely `.start()` and `.end()`. If the API differs (e.g., `.begin()`, `.first()`, `.last()`), check `docs.rs/http-range-header` and use the correct names. Do NOT guess — look at the actual type returned by `.validate()`.

    **Note on FileStream::try_range_response API:** Check the actual axum-extra 0.12 docs for exact signature. It may be `FileStream::try_range_response(path, start, end)` or may differ slightly. Adjust as needed from the actual API. Alternative: if `try_range_response` doesn't exist, build manually:
    - Open file with `tokio::fs::File::open(path).await`
    - Seek to `start` with `file.seek(SeekFrom::Start(start)).await`
    - Read `(end - start + 1)` bytes with `file.take(end - start + 1)` wrapped in `ReaderStream` then `Body::from_stream`
    - Return 206 with `Content-Range: bytes {start}-{end}/{total}` header

    **CRITICAL DLNA header for 206 responses:** The DLNA headers (Accept-Ranges, transferMode.dlna.org, contentFeatures.dlna.org) MUST be present on 206 responses too, not just 200 responses. The `range_response` function receives `headers` (the DLNA HeaderMap) and merges them into the FileStream response — this ensures Samsung TV gets the DLNA headers on both full and partial responses.

    **Do NOT** use `spawn_blocking` for file I/O. Use `tokio::fs` (CONTEXT.md locked decision).
    **Do NOT** return 400 for malformed UUID — return 404 (CONTEXT.md locked decision).
    **Do NOT** hand-roll Range header parsing — use `http-range-header` (research guidance).
  </action>
  <verify>
    `cargo build` exits 0.
    `cargo test` passes all existing tests.
    Full integration test happens in Plan 03 once main.rs is wired. At this stage, verify handler logic compiles and the stub route in mod.rs routes to these handlers.
  </verify>
  <done>
    serve_media_get implemented with: full GET (200 + DLNA headers + streaming body), Range GET (206 + Content-Range + DLNA headers), 416 for unsatisfiable range, 404 for unknown/malformed ID, 500 + error log for missing file.
    serve_media_head implemented: 200 + all DLNA headers, no body, no file open.
    All DLNA headers present on all response types.
    cargo build exits 0.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo build` exits 0
2. `cargo test` passes all existing tests (47+ from Phase 2)
3. `grep "DLNA_CONTENT_FEATURES" src/http/media.rs` confirms constant with 32-char DLNA.ORG_FLAGS
4. `grep "parse_range_header" src/http/media.rs` confirms http-range-header is used
5. `grep "tokio::fs::File::open" src/http/media.rs` confirms async file I/O (not spawn_blocking)
6. `grep "NOT_FOUND" src/http/media.rs` confirms 404 for both UUID parse error and unknown ID
</verification>

<success_criteria>
- serve_media_get: 200 for full GET, 206 for Range GET, 416 for unsatisfiable range, 404 for unknown/bad ID, 500 for missing file
- serve_media_head: 200 with all headers, no body, no file open
- DLNA headers on all responses: Accept-Ranges: bytes, transferMode.dlna.org: Streaming, contentFeatures.dlna.org with 32-char DLNA.ORG_FLAGS
- cargo build exits 0, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-server-file-streaming/03-02-SUMMARY.md`
</output>
