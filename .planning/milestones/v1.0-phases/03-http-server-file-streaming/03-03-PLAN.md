---
phase: 03-http-server-file-streaming
plan: "03"
type: execute
wave: 3
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - src/main.rs
autonomous: false
requirements:
  - STRM-01
  - STRM-02
  - STRM-03
  - STRM-04
  - STRM-05
  - STRM-06
  - STRM-07

must_haves:
  truths:
    - "udlna /path/to/media starts an HTTP server and logs the port it is listening on"
    - "curl http://localhost:8200/media/{id} returns the correct file bytes with correct Content-Type"
    - "curl -I http://localhost:8200/media/{id} returns 200 with Content-Length, Accept-Ranges, and DLNA headers and no body"
    - "curl -H 'Range: bytes=0-99' http://localhost:8200/media/{id} returns 206 with exactly 100 bytes and Content-Range header"
    - "curl http://localhost:8200/device.xml returns 501 Not Implemented (Phase 4 stub)"
    - "curl -X POST http://localhost:8200/cds/control returns 501 Not Implemented (Phase 5 stub)"
    - "Server binds to 0.0.0.0:8200 AND :::8200 by default (dual-bind)"
    - "Server binds to 127.0.0.1:8200 only when --localhost flag is passed"
  artifacts:
    - path: "src/main.rs"
      provides: "async fn main with #[tokio::main], AppState construction, dual-bind or localhost-only server startup"
      contains: "tokio::main"
  key_links:
    - from: "src/main.rs"
      to: "src/http/mod.rs"
      via: "http::build_router(state)"
      pattern: "build_router"
    - from: "src/main.rs"
      to: "src/http/state.rs"
      via: "AppState { library: Arc::clone(&library) }"
      pattern: "AppState"
    - from: "src/main.rs"
      to: "tokio::net::TcpListener"
      via: "TcpListener::bind(...).await for dual-bind or localhost-only"
      pattern: "TcpListener::bind"
---

<objective>
Transition main.rs from synchronous `fn main` to `async fn main` with `#[tokio::main]`, construct AppState from the scanned library, build the axum router, and bind TCP listener(s) based on the `localhost` config flag.

Purpose: Connects all prior Phase 3 work into a running HTTP server. After this plan, any HTTP client can stream files.
Output: Working udlna binary serving media over HTTP with full Range support and DLNA headers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-server-file-streaming/03-CONTEXT.md
@.planning/phases/03-http-server-file-streaming/03-RESEARCH.md
@.planning/phases/03-http-server-file-streaming/03-01-SUMMARY.md
@.planning/phases/03-http-server-file-streaming/03-02-SUMMARY.md

@src/main.rs
@src/config.rs
@src/http/mod.rs
@src/http/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Transition main.rs to async and wire HTTP server with dual-bind</name>
  <files>src/main.rs</files>
  <action>
    Rewrite `src/main.rs` to:

    1. Change `fn main()` to `async fn main()` with `#[tokio::main]` attribute
    2. Keep existing startup sequence intact: tracing init -> CLI parse -> config load -> path validation -> banner -> scan -> zero-file guard
    3. Remove `_library` underscore prefix -- rename to `library` (now consumed by AppState)
    4. Construct AppState from the library Arc
    5. Build the router via `http::build_router(state)`
    6. Bind TCP listener(s) and serve based on `config.localhost`

    **Full main.rs structure:**

    ```rust
    use std::sync::{Arc, RwLock};
    use clap::Parser;

    mod cli;
    mod config;
    mod http;
    mod media;

    #[tokio::main]
    async fn main() {
        tracing_subscriber::fmt()
            .with_env_filter(
                tracing_subscriber::EnvFilter::try_from_default_env()
                    .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
            )
            .init();

        let args = cli::Args::parse();

        let file_config = config::find_config_file(args.config.as_deref())
            .and_then(|path| {
                match config::load_config(&path) {
                    Ok(cfg) => {
                        tracing::debug!("Loaded config from {}", path.display());
                        Some(cfg)
                    }
                    Err(e) => {
                        tracing::warn!("Failed to parse config file: {}", e);
                        None
                    }
                }
            });

        let config = config::Config::resolve(file_config, &args);

        for path in &config.paths {
            if !path.exists() {
                eprintln!("error: path does not exist: {}", path.display());
                std::process::exit(1);
            }
            if !path.is_dir() {
                eprintln!("error: not a directory: {}", path.display());
                std::process::exit(1);
            }
        }

        tracing::info!("udlna v{} -- scanning media directories...", env!("CARGO_PKG_VERSION"));
        for path in &config.paths {
            tracing::info!("  {}", path.display());
        }
        tracing::info!("Server name: \"{}\"", config.name);

        // Synchronous scan -- blocks the thread; acceptable since server has not started yet
        let library = media::scanner::scan(&config.paths);

        if library.items.is_empty() {
            eprintln!("error: no media files found in the provided paths -- exiting");
            std::process::exit(1);
        }

        let library = Arc::new(RwLock::new(library));
        let state = http::state::AppState {
            library: Arc::clone(&library),
        };
        let app = http::build_router(state);

        if config.localhost {
            let addr = format!("127.0.0.1:{}", config.port);
            tracing::info!(
                "Serving {} media items on http://{} (localhost only)",
                library.read().unwrap().items.len(),
                addr
            );
            let listener = tokio::net::TcpListener::bind(&addr)
                .await
                .unwrap_or_else(|e| {
                    eprintln!("error: failed to bind {}: {}", addr, e);
                    std::process::exit(1);
                });
            axum::serve(listener, app).await.unwrap_or_else(|e| {
                eprintln!("error: server error: {}", e);
                std::process::exit(1);
            });
        } else {
            // Dual-bind: separate IPv4 (0.0.0.0) and IPv6 (:::) sockets.
            // Use TcpSocket for IPv6 to explicitly set IPV6_V6ONLY=true.
            // Linux defaults IPV6_V6ONLY=false (shared stack), which causes
            // "Address already in use" when both 0.0.0.0 and ::: are bound.
            // Setting IPV6_V6ONLY=true makes both sockets independent on all OSes.
            let ipv4_addr = format!("0.0.0.0:{}", config.port);
            let item_count = library.read().unwrap().items.len();
            tracing::info!(
                "Serving {} media items on port {} (IPv4 + IPv6)",
                item_count,
                config.port
            );

            let ipv4_listener = tokio::net::TcpListener::bind(&ipv4_addr)
                .await
                .unwrap_or_else(|e| {
                    eprintln!("error: failed to bind IPv4 {}: {}", ipv4_addr, e);
                    std::process::exit(1);
                });

            // Use TcpSocket for IPv6 to set IPV6_V6ONLY=true (portable behavior)
            let ipv6_socket = tokio::net::TcpSocket::new_v6().unwrap_or_else(|e| {
                eprintln!("error: failed to create IPv6 socket: {}", e);
                std::process::exit(1);
            });
            ipv6_socket.set_only_v6(true).unwrap_or_else(|e| {
                tracing::warn!("Could not set IPV6_V6ONLY: {} -- dual-bind may fail on Linux", e);
            });
            let ipv6_addr_parsed: std::net::SocketAddr = format!(":::{}", config.port)
                .parse()
                .unwrap_or_else(|e| {
                    eprintln!("error: failed to parse IPv6 address: {}", e);
                    std::process::exit(1);
                });
            ipv6_socket.bind(ipv6_addr_parsed).unwrap_or_else(|e| {
                eprintln!("error: failed to bind IPv6 :::{}: {}", config.port, e);
                std::process::exit(1);
            });
            let ipv6_listener = ipv6_socket.listen(1024).unwrap_or_else(|e| {
                eprintln!("error: failed to listen on IPv6 socket: {}", e);
                std::process::exit(1);
            });

            let app_v4 = app.clone();
            let h4 = tokio::spawn(async move {
                axum::serve(ipv4_listener, app_v4).await.unwrap_or_else(|e| {
                    tracing::error!("IPv4 server error: {}", e);
                });
            });
            let h6 = tokio::spawn(async move {
                axum::serve(ipv6_listener, app).await.unwrap_or_else(|e| {
                    tracing::error!("IPv6 server error: {}", e);
                });
            });

            tokio::join!(h4, h6);
        }
    }
    ```

    **Key behaviors to preserve from Phase 2 main.rs (DO NOT change):**
    - tracing init (identical)
    - CLI parse (identical)
    - Config load with warn-on-error (identical)
    - Config::resolve (identical)
    - Path validation with eprintln + exit(1) (identical)
    - startup banner (identical)
    - scan() call (synchronous, identical)
    - zero-file guard with eprintln + exit(1) (identical)

    **The only changes from Phase 2 main.rs:**
    - `fn main()` becomes `async fn main()` with `#[tokio::main]`
    - `_library` becomes `library` (remove underscore -- now consumed by AppState)
    - Add `mod http;` declaration (if not already added in Plan 01 Task 2)
    - Add AppState construction, router build, and socket bind/serve code after zero-file guard
    - Replace Phase 2 placeholder ready log with actual server startup log

    **Dual-bind IPv6 pitfall (Pitfall 3 from RESEARCH.md):** On Linux, `:::port` and `0.0.0.0:port`
    can conflict because Linux defaults `IPV6_V6ONLY=false`. `TcpSocket::new_v6().set_only_v6(true)`
    makes the IPv6 socket IPv6-only regardless of OS. On macOS, `IPV6_V6ONLY=true` is the default
    so both binds succeed without the flag -- the explicit flag is safe on macOS too.

    **Lock safety:** `library.read().unwrap().items.len()` for the log is sync and happens before
    `tokio::spawn` -- no Send issue. `Arc::clone(&library)` in AppState is independent from the
    log reference.
  </action>
  <verify>
    1. `cargo build` exits 0 with no errors
    2. `cargo test` passes all existing tests (47+ from prior phases)
    3. Start server: `cargo run -- /path/to/media-dir` (use any directory with at least one video/audio/image file)
    4. Server logs show "Serving N media items on port 8200 (IPv4 + IPv6)"
    5. `curl -s -o /dev/null -w "%{http_code}" http://localhost:8200/media/00000000-0000-0000-0000-000000000000` returns 404
    6. `curl -s -o /dev/null -w "%{http_code}" http://localhost:8200/device.xml` returns 501
  </verify>
  <done>
    cargo build exits 0. Server starts and logs item count and port. Server binds to both 0.0.0.0:8200 and :::8200 by default. With --localhost, binds only to 127.0.0.1:8200. All existing tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end HTTP streaming with curl</name>
  <action>
    Human verification of the complete Phase 3 HTTP server. Run the 7 curl tests described in how-to-verify. No code changes required -- this task is pure verification.
  </action>
  <files>none (verification only)</files>
  <verify>All 7 curl tests pass as described in how-to-verify.</verify>
  <done>User confirms: GET 200, HEAD 200 with DLNA headers no body, Range GET 206, unsatisfiable range 416, stub routes 501, unknown UUID 404.</done>
  <what-built>
    Complete Phase 3 HTTP server wired end-to-end:
    - axum HTTP server bound to 0.0.0.0:8200 + :::8200 (dual-bind)
    - /media/{id} GET: streams full file with DLNA headers
    - /media/{id} GET with Range header: 206 Partial Content with Content-Range
    - /media/{id} HEAD: 200 with all headers, no body, no file open
    - All Phase 4/5 routes as 501 stubs
  </what-built>
  <how-to-verify>
    Start the server with a media directory containing at least one video/audio/image file:

    ```
    cargo run -- /path/to/your/media
    ```

    Server should log something like:
    ```
    INFO udlna v0.1.0 -- scanning media directories...
    INFO Serving 42 media items on port 8200 (IPv4 + IPv6)
    ```

    To get a real item UUID, enable debug logging:
    ```
    RUST_LOG=debug cargo run -- /path/to/media 2>&1 | head -50
    ```
    The scan logs each item's UUID. Copy one UUID for the tests below.

    **Test 1 -- GET full file (STRM-01):**
    ```
    curl -sv http://localhost:8200/media/{your-uuid} -o /dev/null 2>&1 | grep "< HTTP"
    ```
    Expected: HTTP/1.1 200 OK

    **Test 2 -- HEAD request (STRM-02):**
    ```
    curl -sI http://localhost:8200/media/{your-uuid}
    ```
    Expected: HTTP/1.1 200 OK with Content-Length, Accept-Ranges: bytes,
    transferMode.dlna.org: Streaming, contentFeatures.dlna.org header. No body bytes.

    **Test 3 -- Range request 206 (STRM-03, STRM-04):**
    ```
    curl -sv -H "Range: bytes=0-99" http://localhost:8200/media/{your-uuid} -o /tmp/range_test 2>&1 | grep -E "< HTTP|< [Cc]ontent-[Rr]ange|< [Aa]ccept"
    ls -la /tmp/range_test
    ```
    Expected: HTTP/1.1 206 Partial Content, Content-Range: bytes 0-99/{total}, file is 100 bytes

    **Test 4 -- DLNA headers on full GET (STRM-05, STRM-06):**
    ```
    curl -sI http://localhost:8200/media/{your-uuid} | grep -i "dlna\|transfer\|features"
    ```
    Expected: transferMode.dlna.org: Streaming
    Expected: contentFeatures.dlna.org: DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000

    **Test 5 -- 416 for unsatisfiable range:**
    ```
    curl -sv -H "Range: bytes=999999999-9999999999" http://localhost:8200/media/{your-uuid} 2>&1 | grep -E "< HTTP|< content-range"
    ```
    Expected: HTTP/1.1 416 Range Not Satisfiable, content-range: bytes */{total_size}

    **Test 6 -- 501 stub routes:**
    ```
    curl -sv http://localhost:8200/device.xml 2>&1 | grep "< HTTP"
    curl -sv -X POST http://localhost:8200/cds/control 2>&1 | grep "< HTTP"
    ```
    Expected: HTTP/1.1 501 Not Implemented for both

    **Test 7 -- 404 for unknown UUID:**
    ```
    curl -sv http://localhost:8200/media/00000000-0000-0000-0000-000000000000 2>&1 | grep "< HTTP"
    ```
    Expected: HTTP/1.1 404 Not Found with empty body
  </how-to-verify>
  <resume-signal>Type "approved" if all 7 tests pass. Describe any failures (include curl output) so they can be diagnosed and fixed.</resume-signal>
</task>

</tasks>

<verification>
Phase 3 complete when:
1. `cargo build` exits 0
2. `cargo test` passes all existing tests
3. Human-verified: GET returns file with DLNA headers, HEAD returns headers only, Range returns 206, 416 for bad range, stub routes return 501
4. Dual-bind confirmed: server logs "IPv4 + IPv6" and both sockets respond to curl
</verification>

<success_criteria>
- Server starts and binds (dual-bind or localhost-only per config)
- curl GET /media/{id}: 200 + correct Content-Type + streaming file body
- curl HEAD /media/{id}: 200 + Content-Length + Accept-Ranges + transferMode.dlna.org + contentFeatures.dlna.org + no body
- curl GET with Range: 206 + Content-Range: bytes start-end/total + DLNA headers
- curl GET with invalid range: 416 + Content-Range: bytes */{size}
- curl GET /device.xml: 501
- curl POST /cds/control: 501
- All existing unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-server-file-streaming/03-03-SUMMARY.md`
</output>
