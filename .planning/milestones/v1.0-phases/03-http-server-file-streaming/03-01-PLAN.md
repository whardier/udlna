---
phase: 03-http-server-file-streaming
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/cli.rs
  - src/config.rs
  - src/http/mod.rs
  - src/http/state.rs
autonomous: true
requirements:
  - STRM-07

must_haves:
  truths:
    - "cargo build exits 0 after adding axum/axum-extra/tower-http/http-range-header/tokio-util deps"
    - "Config.localhost field exists and defaults to false (dual-bind mode)"
    - "AppState struct holds Arc<RwLock<MediaLibrary>> and implements Clone+Send+Sync"
    - "Router scaffold registers /media/{id}, /device.xml, /cds/scpd.xml, /cms/scpd.xml, /cds/control, /cms/control"
    - "MediaItem.file_size is accessible through AppState.library for STRM-07 size attribute"
  artifacts:
    - path: "Cargo.toml"
      provides: "axum 0.8, axum-extra 0.12 (file-stream), tower-http 0.6 (trace), http-range-header 0.4, tokio 1 (macros+rt-multi-thread+fs+net+io-util), tokio-util 0.7 (io) dependencies"
      contains: "axum"
    - path: "src/cli.rs"
      provides: "--localhost flag (bool, defaults false)"
      contains: "localhost"
    - path: "src/config.rs"
      provides: "FileConfig.localhost: Option<bool>, Config.localhost: bool"
      contains: "localhost"
    - path: "src/http/mod.rs"
      provides: "build_router(state: AppState) -> Router with full route scaffold"
      exports: ["build_router"]
    - path: "src/http/state.rs"
      provides: "AppState struct with library field"
      exports: ["AppState"]
  key_links:
    - from: "src/config.rs"
      to: "src/cli.rs"
      via: "Config::resolve reads args.localhost"
      pattern: "args\\.localhost"
    - from: "src/http/mod.rs"
      to: "src/http/state.rs"
      via: "build_router accepts AppState"
      pattern: "AppState"
    - from: "src/http/state.rs"
      to: "src/media/library.rs"
      via: "AppState.library: Arc<RwLock<MediaLibrary>>"
      pattern: "Arc.*RwLock.*MediaLibrary"
---

<objective>
Add axum and all HTTP dependencies to Cargo.toml, extend config/CLI with the `localhost` bind flag, and create the http module with AppState and router scaffold (all routes registered, Phase 4/5 routes as 501 stubs).

Purpose: Establishes the HTTP foundation so Plan 02 (media handler) and Plan 03 (server bind) can be implemented without touching Cargo.toml or config again.
Output: Compilable codebase with http module compiling, all routes declared, AppState holding the media library.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-http-server-file-streaming/03-CONTEXT.md
@.planning/phases/03-http-server-file-streaming/03-RESEARCH.md

# Prior phase artifacts needed
@.planning/phases/02-media-scanner-and-metadata/02-04-SUMMARY.md
@src/config.rs
@src/cli.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HTTP dependencies to Cargo.toml and extend config/CLI with localhost flag</name>
  <files>Cargo.toml, src/cli.rs, src/config.rs</files>
  <action>
    **Cargo.toml** — add these dependencies (leave existing deps untouched):
    ```toml
    axum = { version = "0.8", features = ["tokio", "http1", "macros"] }
    axum-extra = { version = "0.12", features = ["file-stream"] }
    tower-http = { version = "0.6", features = ["trace"] }
    http-range-header = "0.4"
    tokio = { version = "1", features = ["macros", "rt-multi-thread", "fs", "net", "io-util"] }
    tokio-util = { version = "0.7", features = ["io"] }
    ```

    **src/cli.rs** — add `localhost` flag to Args struct. It is a plain bool (flag presence = true, absence = false). Add after the existing `config` field:
    ```rust
    /// Bind to localhost only (127.0.0.1) instead of all interfaces (0.0.0.0 + :::)
    #[arg(long)]
    pub localhost: bool,
    ```

    **src/config.rs** — extend both structs and Config::resolve:
    - `FileConfig`: add `pub localhost: Option<bool>,`
    - `Config`: add `pub localhost: bool,`
    - `Config::resolve`: add `localhost: args.localhost || file.localhost.unwrap_or(false),`
      (CLI flag `--localhost` sets `args.localhost = true`; TOML `localhost = true` is also honored; default is `false`)
    - Update the `make_args` test helper to include `localhost: false` in the Args construction.
    - Add one new test `test_localhost_default_false` verifying `config.localhost == false` when neither CLI nor TOML sets it.

    Config::resolve merge for localhost: CLI flag is a bool (not Option), so use `args.localhost || file.localhost.unwrap_or(false)`. This means `--localhost` in CLI or `localhost = true` in TOML both activate it.

    Do NOT add `#[serde(deny_unknown_fields)]` to FileConfig (established pattern from Phase 1 — forward compatibility).
  </action>
  <verify>cargo build exits 0 with no errors (warnings are acceptable for unused http module items)</verify>
  <done>Cargo.toml contains axum/axum-extra/tower-http/http-range-header/tokio/tokio-util; src/cli.rs has `localhost: bool` field; src/config.rs has `localhost: bool` in Config and `localhost: Option&lt;bool&gt;` in FileConfig; cargo build succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create src/http module with AppState and router scaffold</name>
  <files>src/http/mod.rs, src/http/state.rs</files>
  <action>
    Create the `src/http/` directory and two files.

    **src/http/state.rs**:
    ```rust
    use std::sync::{Arc, RwLock};
    use crate::media::library::MediaLibrary;

    /// Shared application state injected into all route handlers via axum::extract::State.
    /// Arc provides cheap clone; RwLock provides thread-safe read access.
    /// Write-once at startup (scan), then read-only for server lifetime.
    #[derive(Clone)]
    pub struct AppState {
        pub library: Arc<RwLock<MediaLibrary>>,
    }
    ```

    **src/http/mod.rs**:
    ```rust
    pub mod media;
    pub mod state;

    use axum::{routing::get, Router};
    use tower_http::trace::TraceLayer;
    use crate::http::state::AppState;

    pub fn build_router(state: AppState) -> Router {
        Router::new()
            // Phase 3 — implemented in media.rs
            .route("/media/{id}", get(media::serve_media_get).head(media::serve_media_head))
            // Phase 4 stubs — replaced when device/SCPD XML is implemented
            .route("/device.xml", get(|| async {
                (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
            }))
            .route("/cds/scpd.xml", get(|| async {
                (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
            }))
            .route("/cms/scpd.xml", get(|| async {
                (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
            }))
            // Phase 5 stubs — SOAP control endpoints
            .route("/cds/control", axum::routing::post(|| async {
                (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
            }))
            .route("/cms/control", axum::routing::post(|| async {
                (axum::http::StatusCode::NOT_IMPLEMENTED, "Not Implemented")
            }))
            .layer(TraceLayer::new_for_http())
            .with_state(state)
    }
    ```

    IMPORTANT: axum 0.8 uses `{id}` path syntax (NOT `:id` — that is the old axum 0.7 syntax and will not match).

    Also create a stub `src/http/media.rs` so the mod declaration compiles. It only needs the two handler function signatures returning a placeholder:
    ```rust
    use axum::{extract::{Path, State}, http::HeaderMap, response::Response};
    use crate::http::state::AppState;

    pub async fn serve_media_get(
        State(_state): State<AppState>,
        Path(_id): Path<String>,
        _headers: HeaderMap,
    ) -> Response {
        axum::http::StatusCode::NOT_IMPLEMENTED.into_response()
    }

    pub async fn serve_media_head(
        State(_state): State<AppState>,
        Path(_id): Path<String>,
    ) -> Response {
        axum::http::StatusCode::NOT_IMPLEMENTED.into_response()
    }
    ```
    (These stubs are replaced in Plan 02.)

    Add `mod http;` to src/main.rs so the module is compiled. Do NOT wire http into the server yet — that is Plan 03. Just add the module declaration.
  </action>
  <verify>cargo build exits 0; `cargo build 2>&amp;1 | grep "^error"` produces no output</verify>
  <done>src/http/mod.rs, src/http/state.rs, and src/http/media.rs (stub) exist; `mod http;` declared in main.rs; cargo build succeeds; router scaffold has all 6 routes registered</done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo build` exits 0
2. `grep -r "localhost" src/config.rs` shows both FileConfig and Config fields
3. `grep -r "localhost" src/cli.rs` shows the Args field
4. `grep "axum" Cargo.toml` shows axum dependency
5. `ls src/http/` shows mod.rs, state.rs, media.rs
6. `grep "/media/{id}" src/http/mod.rs` confirms axum 0.8 syntax (not :id)
</verification>

<success_criteria>
- Cargo.toml has axum 0.8, axum-extra 0.12 (file-stream), tower-http 0.6, http-range-header 0.4, tokio with required features, tokio-util 0.7
- Config struct has `localhost: bool` defaulting to false
- AppState holds Arc&lt;RwLock&lt;MediaLibrary&gt;&gt; and is Clone+Send+Sync
- Router scaffold has all 6 routes; Phase 4/5 stubs return 501
- cargo build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-http-server-file-streaming/03-01-SUMMARY.md`
</output>
