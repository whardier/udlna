---
phase: 02-media-scanner-and-metadata
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/media/library.rs
autonomous: true
requirements:
  - CLI-02
  - INDX-01

must_haves:
  truths:
    - "MediaItem struct exists with all fields downstream phases need: id, path, file_size, mime, kind, and meta"
    - "MediaMeta struct holds optional duration, resolution, bitrate, and dlna_profile fields"
    - "MediaLibrary holds a flat Vec<MediaItem> and can be constructed empty then populated"
    - "All Phase 2 crate dependencies compile with no errors after Cargo.toml update"
  artifacts:
    - path: "src/media/library.rs"
      provides: "MediaItem, MediaMeta, MediaLibrary type definitions"
      contains: "pub struct MediaItem"
    - path: "Cargo.toml"
      provides: "walkdir, symphonia, mp4, imagesize, uuid, machine-uid dependencies"
      contains: "walkdir"
  key_links:
    - from: "src/media/library.rs"
      to: "src/media/mime.rs"
      via: "use crate::media::mime::MediaKind"
      pattern: "MediaKind"
    - from: "src/media/library.rs"
      to: "uuid crate"
      via: "uuid::Uuid field on MediaItem"
      pattern: "uuid::Uuid"
---

<objective>
Define the core data types for the media library and add all Phase 2 crate dependencies to Cargo.toml.

Purpose: Every downstream task in this phase depends on MediaItem/MediaMeta/MediaLibrary types existing first. Adding all crates now lets plans 02 and 03 compile without incremental Cargo.toml edits.
Output: src/media/library.rs with type definitions; Cargo.toml updated with 6 new dependencies; `cargo build` passes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-media-scanner-and-metadata/02-CONTEXT.md
@.planning/phases/02-media-scanner-and-metadata/02-RESEARCH.md
@src/media/mime.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 2 crate dependencies to Cargo.toml</name>
  <files>Cargo.toml</files>
  <action>
Add the following dependencies to the `[dependencies]` section of Cargo.toml. These are the exact versions from the research document:

```toml
walkdir = "2"
symphonia = { version = "0.5", features = ["mp3", "aac", "isomp4", "mkv", "flac", "ogg", "wav"] }
mp4 = "0.14"
imagesize = "0.14"
uuid = { version = "1", features = ["v5"] }
machine-uid = "0.5"
```

Do NOT add any other dependencies. Do NOT change existing dependencies (clap, serde, toml, dirs, mime_guess, tracing, tracing-subscriber).

After editing, run `cargo fetch` to download crates and verify no version conflicts. Then run `cargo build` to confirm the binary still compiles with all new crates available (even if unused yet — compiler will warn about unused imports, which is acceptable at this stage).
  </action>
  <verify>
`cargo build` exits 0. Running `cargo metadata --format-version 1 | grep '"name"' | grep -E 'walkdir|symphonia|mp4|imagesize|uuid|machine'` shows all 6 crates appear in the resolved dependency graph.
  </verify>
  <done>Cargo.toml contains all 6 new dependencies, `cargo build` succeeds, all crates are resolvable.</done>
</task>

<task type="auto">
  <name>Task 2: Define MediaItem, MediaMeta, and MediaLibrary in src/media/library.rs</name>
  <files>src/media/library.rs</files>
  <action>
Create `src/media/library.rs` with the following types exactly as specified in RESEARCH.md Pattern 1. These types are the contract that all downstream code (metadata.rs, scanner.rs, HTTP server, SOAP handler) depends on — define them correctly now.

```rust
use std::path::PathBuf;
use uuid::Uuid;
use crate::media::mime::MediaKind;

/// Metadata extracted from file headers at scan time.
/// All fields are Option — extraction may fail for any given file.
#[derive(Debug, Clone)]
pub struct MediaMeta {
    /// UPnP duration format: "HH:MM:SS.mmm" (INDX-02). None if extraction failed.
    pub duration: Option<String>,
    /// Pixel dimensions: "WxH" (INDX-03). None if not applicable or extraction failed.
    pub resolution: Option<String>,
    /// Bitrate in bits per second (INDX-01). None if not available.
    pub bitrate: Option<u32>,
    /// DLNA profile name e.g. "MP3", "AVC_MP4_MP_HD_720p_AAC" (INDX-04).
    /// None means omit DLNA.ORG_PN= from protocolInfo entirely — do NOT use wildcard.
    pub dlna_profile: Option<&'static str>,
}

impl Default for MediaMeta {
    fn default() -> Self {
        Self {
            duration: None,
            resolution: None,
            bitrate: None,
            dlna_profile: None,
        }
    }
}

/// A single discovered media file with all metadata extracted at scan time.
#[derive(Debug, Clone)]
pub struct MediaItem {
    /// Stable UUIDv5: uuid5(machine_namespace, canonical_path_bytes). Same file on same
    /// machine always produces the same ID across server restarts (CONTEXT.md locked).
    pub id: Uuid,
    /// Canonical absolute path (via std::fs::canonicalize — resolves symlinks and .././).
    pub path: PathBuf,
    /// File size in bytes, used in DIDL-Lite <res size="..."> (STRM-07).
    pub file_size: u64,
    /// MIME type string from Phase 1 classify() — static str, e.g. "video/mp4".
    pub mime: &'static str,
    /// Media kind from Phase 1 classify() — Video, Audio, or Image (not Subtitle).
    pub kind: MediaKind,
    /// Extracted metadata. Fields are None when extraction failed or not applicable.
    pub meta: MediaMeta,
}

/// Flat in-memory media library built synchronously at startup.
/// Wrapped in Arc<RwLock<MediaLibrary>> in main.rs for thread-safe sharing.
/// Library is write-once at startup, then read-only for the server lifetime.
#[derive(Debug, Default)]
pub struct MediaLibrary {
    /// All discovered media items. No subtitle items — subtitles are filtered at scan time.
    pub items: Vec<MediaItem>,
}

impl MediaLibrary {
    pub fn new() -> Self {
        Self::default()
    }
}
```

After creating this file, also update `src/media/mod.rs` to expose the new module:

```rust
#![allow(dead_code)]

pub mod mime;
pub mod library;
```

Then run `cargo build` to confirm library.rs compiles and types are visible.

Key constraints from CONTEXT.md (LOCKED decisions):
- `dlna_profile: Option<&'static str>` — never wildcard `"*"`, use None when unknown
- `path: PathBuf` stores the canonical path (canonicalize result), not the raw walkdir path
- `MediaLibrary.items` must NOT contain Subtitle kind items (filtered in scanner)
  </action>
  <verify>
`cargo build` exits 0 with no errors (unused import warnings for uuid/MediaKind are acceptable). `grep -r "pub struct MediaItem" src/` returns `src/media/library.rs`.
  </verify>
  <done>src/media/library.rs exists with MediaItem, MediaMeta, and MediaLibrary structs. src/media/mod.rs re-exports the library module. `cargo build` compiles successfully.</done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0
2. `cat Cargo.toml | grep -E 'walkdir|symphonia|mp4|imagesize|uuid|machine'` shows all 6 crates
3. `grep -r "pub struct MediaItem" /Users/spencersr/tmp/udlna/src/` returns src/media/library.rs
4. `grep -r "pub mod library" /Users/spencersr/tmp/udlna/src/media/mod.rs` confirms module is exported
5. `grep "dlna_profile: Option<&'static str>" /Users/spencersr/tmp/udlna/src/media/library.rs` confirms field type
</verification>

<success_criteria>
All Phase 2 crate dependencies are in Cargo.toml and resolve without conflict. The MediaItem, MediaMeta, and MediaLibrary types exist in src/media/library.rs with the exact field types that downstream plans depend on. `cargo build` succeeds.
</success_criteria>

<output>
After completion, create `.planning/phases/02-media-scanner-and-metadata/02-01-SUMMARY.md`
</output>
