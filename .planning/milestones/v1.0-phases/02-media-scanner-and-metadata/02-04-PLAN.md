---
phase: 02-media-scanner-and-metadata
plan: "04"
type: execute
wave: 4
depends_on:
  - "02-03"
files_modified:
  - src/main.rs
  - src/media/mod.rs
autonomous: true
requirements:
  - CLI-02

must_haves:
  truths:
    - "Running `udlna /path/to/media` with a real media directory prints the scan summary line with file counts"
    - "Running `udlna /empty-dir` (no media files) exits with a non-zero error code and a clear error message"
    - "The Arc<RwLock<MediaLibrary>> is built in main.rs after scan completes and before the startup-complete log line"
    - "Startup banner prints before scan begins; summary line (from scanner) prints after scan completes"
  artifacts:
    - path: "src/main.rs"
      provides: "scan call, Arc<RwLock<MediaLibrary>> construction, zero-file error exit"
      contains: "Arc::new(RwLock::new"
    - path: "src/media/mod.rs"
      provides: "pub re-exports for all Phase 2 modules"
      contains: "pub mod scanner"
  key_links:
    - from: "src/main.rs"
      to: "src/media/scanner.rs"
      via: "media::scanner::scan(&config.paths)"
      pattern: "scanner::scan"
    - from: "src/main.rs"
      to: "src/media/library.rs"
      via: "Arc::new(RwLock::new(library))"
      pattern: "Arc::new.*RwLock::new"
---

<objective>
Wire the scanner into main.rs: call scan(), check for zero results, wrap in Arc<RwLock<MediaLibrary>>, and update the startup/ready log messages.

Purpose: This plan completes Phase 2 by connecting all the pieces into a working end-to-end flow. After this plan, running `udlna /path` produces a real scan with real metadata and a populated shared media library ready for Phase 3's HTTP server.
Output: Updated src/main.rs with scan call and Arc<RwLock<>> construction; updated src/media/mod.rs exporting all Phase 2 modules; binary runs end-to-end.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-media-scanner-and-metadata/02-CONTEXT.md
@.planning/phases/02-media-scanner-and-metadata/02-RESEARCH.md
@.planning/phases/02-media-scanner-and-metadata/02-03-SUMMARY.md
@src/main.rs
@src/media/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire scan() into main.rs with Arc<RwLock<MediaLibrary>> and zero-file exit guard</name>
  <files>src/main.rs</files>
  <action>
Update `src/main.rs` to call the scanner after path validation and wrap the result in `Arc<RwLock<MediaLibrary>>`. The startup flow must follow this sequence (LOCKED decision from CONTEXT.md):

1. tracing init (already present)
2. CLI parse (already present)
3. Config file load and resolve (already present)
4. Path validation with fail-fast exit (already present)
5. **NEW**: Print startup banner BEFORE scan begins (update the existing banner or keep it — just ensure it prints before `scanner::scan` is called)
6. **NEW**: Call `media::scanner::scan(&config.paths)` — this is synchronous and blocks until complete
7. **NEW**: Check `library.items.is_empty()` — if true, print error and exit(1) (LOCKED: zero files = error)
8. **NEW**: Wrap in `Arc::new(RwLock::new(library))`
9. **NEW**: Log "Ready. Serving {N} media items on port {port}" (replaces the Phase 1 placeholder log)

Add to the top of main.rs:
```rust
use std::sync::{Arc, RwLock};
```

The scan call and wiring:
```rust
// Print banner before scan starts (LOCKED: banner before scan, summary after)
tracing::info!("udlna v{} — scanning media directories...", env!("CARGO_PKG_VERSION"));
for path in &config.paths {
    tracing::info!("  {}", path.display());
}

// Synchronous scan — blocks until all directories are fully walked
let library = media::scanner::scan(&config.paths);

// LOCKED: zero media files found must be an error exit (not a silent empty server)
if library.items.is_empty() {
    eprintln!("error: no media files found in the provided paths — exiting");
    std::process::exit(1);
}

// Wrap in Arc<RwLock<>> for thread-safe sharing in Phase 3+
// Note: library is write-once at startup, then read-only. std::sync::RwLock is safe here.
// If Phase 6+ needs writes (OPER-01 SIGHUP rescan), switch to tokio::sync::RwLock.
let _library = Arc::new(RwLock::new(library));

tracing::info!("Ready. Serving {} media items on port {} (Phase 2 complete — add Phase 3 for HTTP)", _library.read().unwrap().items.len(), config.port);
```

Remove or replace the old Phase 1 placeholder log line: `"Ready. (Phase 1 complete — add Phase 2 for media scanning)"`.

The `_library` variable is prefixed with `_` to suppress the unused-variable warning until Phase 3 uses it. Phase 3 will remove the underscore prefix and pass `Arc::clone(&library)` to the HTTP server.

After editing, run `cargo build` to confirm the binary compiles with no errors. Run `cargo clippy` to check for any lints.
  </action>
  <verify>
`cargo build` exits 0. `grep "Arc::new(RwLock::new" src/main.rs` returns a match. `grep "items.is_empty" src/main.rs` returns a match confirming zero-file guard is present.

To test the zero-file guard: `mkdir /tmp/udlna-empty-test && cargo run -- /tmp/udlna-empty-test; echo "Exit code: $?"` — should print "error: no media files found" and exit code should be 1. Clean up: `rmdir /tmp/udlna-empty-test`.

To test scanning: create a test directory with at least one media file, run `cargo run -- /path/to/dir`, and confirm the "Scanned N files" summary line appears.
  </verify>
  <done>main.rs calls media::scanner::scan(), wraps the result in Arc<RwLock<MediaLibrary>>, exits with code 1 if no media files found, and logs a ready message with item count. cargo build exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Finalize src/media/mod.rs to export all Phase 2 modules</name>
  <files>src/media/mod.rs</files>
  <action>
Update `src/media/mod.rs` to re-export all four Phase 2 modules cleanly. This file is the public interface to the entire media subsystem that main.rs and later phases import through.

```rust
pub mod library;
pub mod metadata;
pub mod mime;
pub mod scanner;
```

Remove the `#![allow(dead_code)]` attribute — it was a Phase 1 stub suppressor. By the end of Phase 2, all modules should have used exports. If any dead_code warnings remain after removing it, they are real warnings to address (not to suppress globally).

After editing, run `cargo build` — if dead_code warnings appear, inspect them:
- If from Phase 1 code that is genuinely unused (e.g., MediaKind variants not yet matched in Phase 2), add targeted `#[allow(dead_code)]` on the specific item, not the whole crate.
- If from Phase 2 code, fix the usage (e.g., ensure all structs/functions are actually called somewhere).

Run `cargo test` to confirm all tests still pass after the mod.rs change.

This is the final task of Phase 2. After it passes, the phase is complete and ready for Phase 3 (HTTP server will clone the Arc and serve files).
  </action>
  <verify>
`cargo build` exits 0. `cargo test` exits 0. `cat src/media/mod.rs` shows all four modules: library, metadata, mime, scanner — all with `pub mod`. `grep "allow(dead_code)" src/media/mod.rs` returns nothing (the file-level suppressor is removed).
  </verify>
  <done>src/media/mod.rs exports all four Phase 2 modules without file-level dead_code suppression. cargo build and cargo test both pass. Phase 2 is complete.</done>
</task>

</tasks>

<verification>
End-to-end verification of the complete Phase 2 scanner:

1. `cargo build` exits 0 with no errors
2. `cargo test` exits 0 — all tests pass (pure function tests from Plan 02 + any integration behavior)
3. Zero-file guard test:
   ```bash
   mkdir /tmp/udlna_test_empty
   cargo run -- /tmp/udlna_test_empty 2>&1; echo "Exit: $?"
   rmdir /tmp/udlna_test_empty
   ```
   Expected: prints error message, exit code 1

4. Real scan test (if a media directory is available):
   ```bash
   cargo run -- /path/to/media/dir 2>&1 | grep "Scanned"
   ```
   Expected: "Scanned N files (X video, Y audio, Z image) in T.Ts"

5. `grep "Arc::new(RwLock::new" /Users/spencersr/tmp/udlna/src/main.rs` — confirms Arc wrapping
6. `grep "pub mod scanner" /Users/spencersr/tmp/udlna/src/media/mod.rs` — confirms export
</verification>

<success_criteria>
The udlna binary scans real media directories, extracts metadata, prints a summary line, builds an Arc<RwLock<MediaLibrary>>, and exits with error on zero results. All Phase 2 requirements (CLI-02, INDX-01 through INDX-04) are satisfied. The binary is ready for Phase 3 to clone the Arc and serve files over HTTP.
</success_criteria>

<output>
After completion, create `.planning/phases/02-media-scanner-and-metadata/02-04-SUMMARY.md`
</output>
