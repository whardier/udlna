---
phase: 02-media-scanner-and-metadata
plan: "03"
type: execute
wave: 3
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/media/metadata.rs
  - src/media/scanner.rs
autonomous: true
requirements:
  - INDX-01
  - INDX-02
  - INDX-03
  - INDX-04

must_haves:
  truths:
    - "extract_metadata() reads audio duration from MP3/FLAC/OGG/WAV/M4A files via symphonia without spawning a process"
    - "extract_metadata() reads MP4 video width, height, and duration via the mp4 crate"
    - "extract_metadata() reads image dimensions (width x height) via imagesize without fully decoding the image"
    - "extract_metadata() returns None for a file that fails extraction — it does not panic or include partial data"
    - "scan_paths() recursively walks all directories following symlinks and returns a populated MediaLibrary"
    - "Subtitle files (MediaKind::Subtitle) are filtered out of MediaLibrary.items"
    - "Missing/unreadable paths log a warn and continue — scan does not abort on a single bad entry"
  artifacts:
    - path: "src/media/metadata.rs"
      provides: "extract_metadata(path, kind, mime) -> Option<MediaMeta> with I/O extraction"
      contains: "pub fn extract_metadata"
    - path: "src/media/scanner.rs"
      provides: "scan_paths(paths, machine_namespace) -> MediaLibrary"
      contains: "pub fn scan_paths"
  key_links:
    - from: "src/media/scanner.rs"
      to: "src/media/metadata.rs"
      via: "extract_metadata() called per file"
      pattern: "extract_metadata"
    - from: "src/media/scanner.rs"
      to: "src/media/mime.rs"
      via: "classify() called per file to determine MediaKind + mime"
      pattern: "classify"
    - from: "src/media/scanner.rs"
      to: "src/media/library.rs"
      via: "MediaItem/MediaLibrary populated during walk"
      pattern: "MediaItem"
    - from: "src/media/metadata.rs"
      to: "symphonia crate"
      via: "MediaSourceStream + Probe for audio duration"
      pattern: "symphonia"
    - from: "src/media/metadata.rs"
      to: "mp4 crate"
      via: "Mp4Reader::read_header for video metadata"
      pattern: "Mp4Reader"
    - from: "src/media/metadata.rs"
      to: "imagesize crate"
      via: "imagesize::size() for image dimensions"
      pattern: "imagesize"
---

<objective>
Implement the I/O metadata extraction function in metadata.rs and the full recursive directory scanner in scanner.rs.

Purpose: These two modules are the core of Phase 2. After this plan, the scanner can walk real directories, extract real metadata from real files, and build a populated MediaLibrary with all required fields.
Output: src/media/metadata.rs with extract_metadata(); src/media/scanner.rs with scan_paths() + scan(); cargo build and cargo test pass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-media-scanner-and-metadata/02-CONTEXT.md
@.planning/phases/02-media-scanner-and-metadata/02-RESEARCH.md
@.planning/phases/02-media-scanner-and-metadata/02-01-SUMMARY.md
@.planning/phases/02-media-scanner-and-metadata/02-02-SUMMARY.md
@src/media/library.rs
@src/media/metadata.rs
@src/media/mime.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement extract_metadata() I/O extraction in metadata.rs</name>
  <files>src/media/metadata.rs</files>
  <action>
Add the `extract_metadata` function to the existing `src/media/metadata.rs` (which already has the pure helper functions from Plan 02). This function performs actual file I/O to extract metadata from media files.

```rust
use std::path::Path;
use crate::media::library::MediaMeta;
use crate::media::mime::MediaKind;

/// Extract metadata from a media file by reading its container headers.
/// Returns None if extraction fails entirely — partial data is never returned.
/// Per LOCKED decision: skip files that fail extraction entirely (not include with null fields).
pub fn extract_metadata(path: &Path, kind: MediaKind, mime: &'static str) -> Option<MediaMeta> {
    match kind {
        MediaKind::Audio => extract_audio_meta(path, mime),
        MediaKind::Video => extract_video_meta(path, mime),
        MediaKind::Image => extract_image_meta(path, mime),
        MediaKind::Subtitle => None, // Subtitles are filtered before this is called
    }
}
```

**Audio extraction (extract_audio_meta):**
Use symphonia as described in RESEARCH.md Pattern 3. Key implementation points:
- Create `File::open(path).ok()?`, wrap in `MediaSourceStream::new(Box::new(file), Default::default())`
- Create a `Hint` with the file extension via `path.extension().and_then(|e| e.to_str())`
- Call `symphonia::default::get_probe().format(...)` — return None on error (don't panic)
- Find first track where `codec != CODEC_TYPE_NULL`
- Duration: `track.codec_params.time_base.and_then(|tb| track.codec_params.n_frames.map(|n| tb.calc_time(n)))`
- If duration is None (VBR MP3 without Xing): log `tracing::debug!("No duration for {}", path.display())` and leave duration as None (LOCKED: skip rather than null)
- Bitrate: `track.codec_params.bits_per_coded_sample.map(|b| b as u32)` as fallback, or 0 as None
- Build MediaMeta with duration = Some(format_upnp_duration(t.seconds, t.frac)), resolution = None, dlna_profile = dlna_profile_for(mime)

**MP4 video extraction (via mp4 crate), only called for MediaKind::Video with mime == "video/mp4" or "video/x-m4v":**
Use RESEARCH.md Pattern 4:
- `Mp4Reader::read_header(BufReader::new(File::open(path).ok()?), file_len).ok()?`
- Find first VideoTrack: iterate `mp4.tracks().values()`, check `track.track_type().ok()? == TrackType::Video`
- duration_ms = `mp4.duration().as_millis() as u64` → format_upnp_duration(duration_ms / 1000, (duration_ms % 1000) as f64 / 1000.0)
- resolution = `format!("{}x{}", track.width(), track.height())`
- Build MediaMeta with all fields populated

**For other video formats (MKV, AVI, etc.):** Use symphonia to get audio track duration (same as audio extraction), leave resolution as None (RESEARCH.md Pitfall 2: symphonia doesn't expose video resolution, and no pure-Rust MKV resolution crate is confirmed). Log `tracing::debug!("No video resolution for {} (non-MP4)", path.display())`.

**Image extraction (extract_image_meta):**
Use RESEARCH.md Pattern 5:
- `imagesize::size(path).ok()` → map to `format!("{}x{}", dim.width, dim.height)`
- Build MediaMeta with resolution = Some(dims_string), duration = None, dlna_profile = dlna_profile_for(mime)
- On Err: log `tracing::warn!("Cannot read image dimensions for {}: {}", path.display(), e)` and return None (LOCKED: skip file on extraction failure)

**Critical anti-patterns to avoid (from RESEARCH.md):**
- Do NOT store `Some("")` — use None when data is unavailable
- Do NOT panic on extraction errors — every path returns Option
- Do NOT use `image::open()` for dimensions — use `imagesize::size()` (header-only, ~16 bytes)
  </action>
  <verify>
`cargo build` exits 0. `grep "pub fn extract_metadata" src/media/metadata.rs` returns a match. `cargo test` exits 0 (all existing Plan 02 pure-function tests still pass).
  </verify>
  <done>extract_metadata() exists and is callable. It handles Audio, Video, and Image kinds. Returns None on any failure without panicking. All existing tests continue to pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement scanner.rs with walkdir traversal and MediaLibrary construction</name>
  <files>src/media/scanner.rs</files>
  <action>
Create `src/media/scanner.rs`. This is the top-level scan function that main.rs will call. It orchestrates walkdir traversal, MIME classification, metadata extraction, and UUID generation to produce a complete MediaLibrary.

```rust
use std::path::{Path, PathBuf};
use std::time::Instant;
use uuid::Uuid;
use walkdir::WalkDir;

use crate::media::library::{MediaItem, MediaLibrary};
use crate::media::metadata::{build_machine_namespace, extract_metadata, media_item_id};
use crate::media::mime::{classify, MediaKind};

/// Statistics collected during scanning for the startup summary line.
pub struct ScanStats {
    pub total: usize,
    pub video: usize,
    pub audio: usize,
    pub image: usize,
    pub elapsed_secs: f64,
}

/// Scan all provided paths and return a MediaLibrary with all discovered media items.
/// Symlinks are followed. Missing/unreadable paths log warn and continue.
/// Per LOCKED decision: MediaKind::Subtitle items are excluded from library.items.
pub fn scan(paths: &[PathBuf]) -> MediaLibrary {
    let start = Instant::now();
    let machine_ns = build_machine_namespace();
    let mut library = MediaLibrary::new();
    let mut video_count = 0usize;
    let mut audio_count = 0usize;
    let mut image_count = 0usize;

    for root in paths {
        // LOCKED: warn and continue if directory is missing — do not abort startup
        if !root.exists() {
            tracing::warn!("Scan path does not exist, skipping: {}", root.display());
            continue;
        }
        for entry in WalkDir::new(root).follow_links(true) {
            match entry {
                Err(e) => {
                    // LOCKED: log warn for unreadable files / broken symlinks, continue
                    tracing::warn!("Cannot access entry: {}", e);
                }
                Ok(entry) if entry.file_type().is_file() => {
                    process_file(entry.path(), &machine_ns, &mut library,
                        &mut video_count, &mut audio_count, &mut image_count);
                }
                Ok(_) => {} // directory entries — walkdir handles recursion
            }
        }
    }

    let elapsed = start.elapsed().as_secs_f64();
    let total = library.items.len();
    tracing::info!(
        "Scanned {} files ({} video, {} audio, {} image) in {:.1}s",
        total, video_count, audio_count, image_count, elapsed
    );

    library
}

fn process_file(
    path: &Path,
    machine_ns: &Uuid,
    library: &mut MediaLibrary,
    video_count: &mut usize,
    audio_count: &mut usize,
    image_count: &mut usize,
) {
    // classify() returns None for non-media files (silently skipped) and for Subtitle kind
    let Some((kind, mime)) = classify(path) else { return };

    // LOCKED: Subtitle files must NOT appear as media items in the library.
    // They are recognized by classify() but excluded here (handled in Phase 3/5).
    if kind == MediaKind::Subtitle {
        tracing::debug!("Subtitle file recognized but excluded from library: {}", path.display());
        return;
    }

    // LOCKED: canonicalize path for UUID stability (Pitfall 5 in RESEARCH.md)
    let canonical = match std::fs::canonicalize(path) {
        Ok(p) => p,
        Err(e) => {
            tracing::warn!("Cannot canonicalize {}: {}", path.display(), e);
            return;
        }
    };

    let file_size = match std::fs::metadata(&canonical) {
        Ok(m) => m.len(),
        Err(e) => {
            tracing::warn!("Cannot stat {}: {}", canonical.display(), e);
            return;
        }
    };

    // LOCKED: skip file entirely on metadata extraction failure (not include with null fields)
    let Some(meta) = extract_metadata(&canonical, kind, mime) else {
        tracing::warn!("Skipping {} — metadata extraction failed", canonical.display());
        return;
    };

    let id = media_item_id(machine_ns, &canonical);

    match kind {
        MediaKind::Video => *video_count += 1,
        MediaKind::Audio => *audio_count += 1,
        MediaKind::Image => *image_count += 1,
        MediaKind::Subtitle => unreachable!("filtered above"),
    }

    library.items.push(MediaItem { id, path: canonical, file_size, mime, kind, meta });
}
```

After creating the file, add `pub mod scanner;` to `src/media/mod.rs`.

Then run `cargo build` to confirm scanner.rs compiles. Run `cargo test` to confirm all tests pass.

**Critical anti-patterns to avoid:**
- Do NOT use `std::fs::read_dir` recursive impl — use walkdir (Pitfall in RESEARCH.md)
- Do NOT hash the raw walkdir path — always canonicalize first (RESEARCH.md Pitfall 5)
- Do NOT include files where extract_metadata returns None (LOCKED: skip on failure)
- Do NOT include Subtitle kind items in library.items (RESEARCH.md Pitfall 3)
  </action>
  <verify>
`cargo build` exits 0. `grep "pub fn scan" src/media/scanner.rs` returns a match. `cargo test` exits 0. `grep "pub mod scanner" src/media/mod.rs` confirms module is exported.
  </verify>
  <done>scanner.rs exists with scan() and process_file() functions. src/media/mod.rs exports scanner module. `cargo build` and `cargo test` both pass with 0 errors.</done>
</task>

</tasks>

<verification>
1. `cargo build` exits 0 with no errors
2. `cargo test` exits 0 — all tests pass (including Plan 02 pure-function tests)
3. `grep "pub fn extract_metadata" /Users/spencersr/tmp/udlna/src/media/metadata.rs` returns match
4. `grep "pub fn scan" /Users/spencersr/tmp/udlna/src/media/scanner.rs` returns match
5. `grep "MediaKind::Subtitle" /Users/spencersr/tmp/udlna/src/media/scanner.rs` confirms subtitle filtering
6. `grep "canonicalize" /Users/spencersr/tmp/udlna/src/media/scanner.rs` confirms canonical path usage
</verification>

<success_criteria>
extract_metadata() handles all three MediaKind variants (Audio via symphonia, Video with MP4/non-MP4 paths, Image via imagesize) and returns None on failure without panicking. scan() uses walkdir with follow_links(true), filters subtitles, canonicalizes paths, and builds a complete MediaLibrary. All cargo build and cargo test checks pass.
</success_criteria>

<output>
After completion, create `.planning/phases/02-media-scanner-and-metadata/02-03-SUMMARY.md`
</output>
